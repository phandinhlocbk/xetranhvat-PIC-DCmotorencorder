CCS PCH C Compiler, Version 4.104, 5967               10-Oct-15 09:28

               Filename: C:\Users\ken\Desktop\ken\CCS\loc.lst

               ROM used: 10496 bytes (32%)
                         Largest free fragment is 22268
               RAM used: 204 (10%) at main() level
                         345 (17%) worst case
               Stack:    8 worst case (5 in main + 3 for interrupts)

*
0000:  GOTO   2730
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  F9D.0
004A:  GOTO   0054
004E:  BTFSC  F9E.0
0050:  GOTO   0CDC
0054:  BTFSS  FF0.3
0056:  GOTO   0060
005A:  BTFSC  FF0.0
005C:  GOTO   0C24
0060:  BTFSS  FF0.4
0062:  GOTO   006C
0066:  BTFSC  FF0.1
0068:  GOTO   0C64
006C:  BTFSS  F9D.5
006E:  GOTO   0078
0072:  BTFSC  F9E.5
0074:  GOTO   0B50
0078:  MOVFF  0E,00
007C:  MOVFF  0F,01
0080:  MOVFF  10,02
0084:  MOVFF  11,03
0088:  MOVFF  0C,FE9
008C:  MOVFF  07,FEA
0090:  BSF    07.7
0092:  MOVFF  08,FE1
0096:  MOVFF  09,FE2
009A:  MOVFF  0A,FD9
009E:  MOVFF  0B,FDA
00A2:  MOVFF  12,FF3
00A6:  MOVFF  13,FF4
00AA:  MOVFF  14,FFA
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #include <STDDEF.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... //////////// 
.................... #DEVICE ADC=10 
.................... #FUSES NOWDT  
.................... #FUSES HSPLL       
.................... #FUSES MCLR       
.................... #FUSES NOPROTECT        
.................... #FUSES NOLVP        
.................... #FUSES NODEBUG        
.................... #FUSES USBDIV        
.................... #FUSES PLL5        
.................... #FUSES CPUDIV1        
.................... #FUSES VREGEN   
.................... #FUSES HS, NOPUT, NOBROWNOUT, NOCPD, NOWRT 
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
*
0118:  MOVFF  138,13D
011C:  MOVFF  137,13C
0120:  MOVLB  1
0122:  MOVF   x3B,F
0124:  BZ    016E
0126:  MOVFF  13A,03
012A:  MOVFF  139,FE9
012E:  MOVFF  13A,FEA
0132:  MOVF   FEF,F
0134:  BZ    016E
....................      *s++ = *s2++; 
0136:  MOVFF  13D,03
013A:  MOVF   x3C,W
013C:  INCF   x3C,F
013E:  BTFSC  FD8.2
0140:  INCF   x3D,F
0142:  MOVWF  x3E
0144:  MOVFF  03,13F
0148:  MOVFF  13A,03
014C:  MOVF   x39,W
014E:  INCF   x39,F
0150:  BTFSC  FD8.2
0152:  INCF   x3A,F
0154:  MOVWF  FE9
0156:  MOVFF  03,FEA
015A:  MOVFF  FEF,140
015E:  MOVFF  13F,FEA
0162:  MOVFF  13E,FE9
0166:  MOVFF  140,FEF
016A:  DECF   x3B,F
016C:  BRA    0122
....................   for (; n > 0; n--) 
016E:  MOVF   x3B,F
0170:  BZ    018A
....................      *s++ = '\0'; 
0172:  MOVFF  13D,03
0176:  MOVF   x3C,W
0178:  INCF   x3C,F
017A:  BTFSC  FD8.2
017C:  INCF   x3D,F
017E:  MOVWF  FE9
0180:  MOVFF  03,FEA
0184:  CLRF   FEF
0186:  DECF   x3B,F
0188:  BRA    016E
....................  
....................   return(s1); 
018A:  MOVFF  137,01
018E:  MOVFF  138,02
.................... } 
0192:  MOVLB  0
0194:  GOTO   0BC2 (RETURN)
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
00DC:  MOVFF  137,139
00E0:  MOVFF  136,138
00E4:  MOVFF  139,03
00E8:  MOVLB  1
00EA:  MOVFF  138,FE9
00EE:  MOVFF  139,FEA
00F2:  MOVF   FEF,F
00F4:  BZ    0102
00F6:  INCF   x38,F
00F8:  BTFSC  FD8.2
00FA:  INCF   x39,F
00FC:  MOVLB  0
00FE:  BRA    00E4
0100:  MOVLB  1
....................    return(sc - s); 
0102:  MOVF   x36,W
0104:  SUBWF  x38,W
0106:  MOVWF  00
0108:  MOVF   x37,W
010A:  SUBWFB x39,W
010C:  MOVWF  03
010E:  MOVFF  00,01
.................... } 
0112:  MOVLB  0
0114:  GOTO   0BA2 (RETURN)
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
*
069A:  MOVLB  1
069C:  CLRF   x3D
069E:  CLRF   x3C
06A0:  CLRF   x3B
06A2:  MOVLW  7F
06A4:  MOVWF  x3A
06A6:  CLRF   x41
06A8:  CLRF   x40
06AA:  CLRF   x3F
06AC:  CLRF   x3E
06AE:  BSF    x42.0
06B0:  BCF    x42.1
06B2:  BCF    x42.2
06B4:  CLRF   x44
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
06B6:  MOVF   x36,W
06B8:  IORWF  x37,W
06BA:  BNZ   06C6
....................       return 0; 
06BC:  CLRF   00
06BE:  CLRF   01
06C0:  CLRF   02
06C2:  CLRF   03
06C4:  BRA    08E4
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
06C6:  MOVF   x44,W
06C8:  INCF   x44,F
06CA:  CLRF   03
06CC:  ADDWF  x36,W
06CE:  MOVWF  FE9
06D0:  MOVF   x37,W
06D2:  ADDWFC 03,W
06D4:  MOVWF  FEA
06D6:  MOVFF  FEF,143
06DA:  MOVF   x43,F
06DC:  BTFSC  FD8.2
06DE:  BRA    086A
....................    { 
....................       if (skip && !isspace(c)) 
06E0:  BTFSS  x42.0
06E2:  BRA    0702
06E4:  MOVF   x43,W
06E6:  SUBLW  20
06E8:  BZ    0702
....................       { 
....................          skip = 0; 
06EA:  BCF    x42.0
....................          if (c == '+') 
06EC:  MOVF   x43,W
06EE:  SUBLW  2B
06F0:  BNZ   06F8
....................          { 
....................             sign = 0; 
06F2:  BCF    x42.1
....................             continue; 
06F4:  BRA    0850
....................          }             
....................          else if (c == '-') 
06F6:  BRA    0702
06F8:  MOVF   x43,W
06FA:  SUBLW  2D
06FC:  BNZ   0702
....................          { 
....................             sign = 1; 
06FE:  BSF    x42.1
....................             continue; 
0700:  BRA    0850
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
0702:  BTFSC  x42.0
0704:  BRA    0714
0706:  MOVF   x43,W
0708:  SUBLW  2E
070A:  BNZ   0714
070C:  BTFSC  x42.2
070E:  BRA    0714
....................          point = 1; 
0710:  BSF    x42.2
....................       else if (!skip && isdigit(c)) 
0712:  BRA    0850
0714:  BTFSC  x42.0
0716:  BRA    084A
0718:  MOVF   x43,W
071A:  SUBLW  2F
071C:  BTFSC  FD8.0
071E:  BRA    084A
0720:  MOVF   x43,W
0722:  SUBLW  39
0724:  BTFSS  FD8.0
0726:  BRA    084A
....................       { 
....................          c -= '0'; 
0728:  MOVLW  30
072A:  SUBWF  x43,F
....................          if (point) 
072C:  BTFSS  x42.2
072E:  BRA    07D6
....................          { 
....................             pow10 = pow10 * 10.0; 
0730:  MOVFF  13D,148
0734:  MOVFF  13C,147
0738:  MOVFF  13B,146
073C:  MOVFF  13A,145
0740:  CLRF   x4C
0742:  CLRF   x4B
0744:  MOVLW  20
0746:  MOVWF  x4A
0748:  MOVLW  82
074A:  MOVWF  x49
074C:  MOVLB  0
074E:  RCALL  0198
0750:  MOVFF  03,13D
0754:  MOVFF  02,13C
0758:  MOVFF  01,13B
075C:  MOVFF  00,13A
....................             result += (float)c / pow10;    
0760:  MOVLB  1
0762:  CLRF   x4A
0764:  MOVFF  143,149
0768:  MOVLB  0
076A:  RCALL  028E
076C:  MOVFF  00,145
0770:  MOVFF  01,146
0774:  MOVFF  02,147
0778:  MOVFF  03,148
077C:  MOVFF  03,14C
0780:  MOVFF  02,14B
0784:  MOVFF  01,14A
0788:  MOVFF  00,149
078C:  MOVFF  13D,150
0790:  MOVFF  13C,14F
0794:  MOVFF  13B,14E
0798:  MOVFF  13A,14D
079C:  RCALL  02C4
079E:  BCF    FD8.1
07A0:  MOVFF  141,14C
07A4:  MOVFF  140,14B
07A8:  MOVFF  13F,14A
07AC:  MOVFF  13E,149
07B0:  MOVFF  03,150
07B4:  MOVFF  02,14F
07B8:  MOVFF  01,14E
07BC:  MOVFF  00,14D
07C0:  RCALL  0422
07C2:  MOVFF  03,141
07C6:  MOVFF  02,140
07CA:  MOVFF  01,13F
07CE:  MOVFF  00,13E
....................          } 
....................          else 
07D2:  BRA    0846
07D4:  MOVLB  1
....................          { 
....................             result = 10.0 * result + (float)c; 
07D6:  CLRF   x48
07D8:  CLRF   x47
07DA:  MOVLW  20
07DC:  MOVWF  x46
07DE:  MOVLW  82
07E0:  MOVWF  x45
07E2:  MOVFF  141,14C
07E6:  MOVFF  140,14B
07EA:  MOVFF  13F,14A
07EE:  MOVFF  13E,149
07F2:  MOVLB  0
07F4:  RCALL  0198
07F6:  MOVFF  00,145
07FA:  MOVFF  01,146
07FE:  MOVFF  02,147
0802:  MOVFF  03,148
0806:  MOVLB  1
0808:  CLRF   x4A
080A:  MOVFF  143,149
080E:  MOVLB  0
0810:  RCALL  028E
0812:  BCF    FD8.1
0814:  MOVFF  148,14C
0818:  MOVFF  147,14B
081C:  MOVFF  146,14A
0820:  MOVFF  145,149
0824:  MOVFF  03,150
0828:  MOVFF  02,14F
082C:  MOVFF  01,14E
0830:  MOVFF  00,14D
0834:  RCALL  0422
0836:  MOVFF  03,141
083A:  MOVFF  02,140
083E:  MOVFF  01,13F
0842:  MOVFF  00,13E
....................          } 
....................       } 
....................       else if (!skip) 
0846:  BRA    0852
0848:  MOVLB  1
084A:  BTFSC  x42.0
084C:  BRA    0850
....................          break; 
084E:  BRA    086A
0850:  MOVLB  0
....................    } 
0852:  MOVLB  1
0854:  MOVF   x44,W
0856:  INCF   x44,F
0858:  CLRF   03
085A:  ADDWF  x36,W
085C:  MOVWF  FE9
085E:  MOVF   x37,W
0860:  ADDWFC 03,W
0862:  MOVWF  FEA
0864:  MOVFF  FEF,143
0868:  BRA    06DA
....................  
....................    if (sign) 
086A:  BTFSS  x42.1
086C:  BRA    08A0
....................       result = -1*result; 
086E:  CLRF   x48
0870:  CLRF   x47
0872:  MOVLW  80
0874:  MOVWF  x46
0876:  MOVLW  7F
0878:  MOVWF  x45
087A:  MOVFF  141,14C
087E:  MOVFF  140,14B
0882:  MOVFF  13F,14A
0886:  MOVFF  13E,149
088A:  MOVLB  0
088C:  RCALL  0198
088E:  MOVFF  03,141
0892:  MOVFF  02,140
0896:  MOVFF  01,13F
089A:  MOVFF  00,13E
089E:  MOVLB  1
....................        
....................    if(endptr) 
08A0:  MOVF   x38,W
08A2:  IORWF  x39,W
08A4:  BZ    08D4
....................    { 
....................       if (ptr) { 
08A6:  MOVF   x44,F
08A8:  BZ    08C2
....................          ptr--; 
08AA:  DECF   x44,F
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
08AC:  MOVFF  138,FE9
08B0:  MOVFF  139,FEA
08B4:  MOVF   x44,W
08B6:  ADDWF  x36,W
08B8:  MOVWF  FEF
08BA:  MOVLW  00
08BC:  ADDWFC x37,W
08BE:  MOVWF  FEC
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
08C0:  BRA    08D4
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
08C2:  MOVFF  138,FE9
08C6:  MOVFF  139,FEA
08CA:  MOVFF  137,FEC
08CE:  MOVF   FED,F
08D0:  MOVFF  136,FEF
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
08D4:  MOVFF  13E,00
08D8:  MOVFF  13F,01
08DC:  MOVFF  140,02
08E0:  MOVFF  141,03
.................... } 
08E4:  MOVLB  0
08E6:  GOTO   0BD4 (RETURN)
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float32)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float32)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float48)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float48)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float64)l); 
....................   res = 32768.0*(float64)l; 
....................   res += (float64)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y/LN2 - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y/LN2 - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y/LN2 - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................    bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float32 const pl_64[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql_64[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
.................... #endif 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................       bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................    bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................      bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI          0.6366197723675813 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
*
1CEA:  CLRF   xEF
1CEC:  CLRF   xEE
1CEE:  CLRF   xED
1CF0:  MOVLW  7F
1CF2:  MOVWF  xEC
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
1CF4:  MOVLW  7E
1CF6:  MOVWF  xF6
1CF8:  MOVLW  80
1CFA:  MOVWF  xF7
1CFC:  CLRF   xF8
1CFE:  CLRF   xF9
1D00:  MOVLW  7A
1D02:  MOVWF  xFA
1D04:  MOVLW  2A
1D06:  MOVWF  xFB
1D08:  MOVLW  AA
1D0A:  MOVWF  xFC
1D0C:  MOVLW  AB
1D0E:  MOVWF  xFD
1D10:  MOVLW  75
1D12:  MOVWF  xFE
1D14:  MOVLW  B6
1D16:  MOVWF  xFF
1D18:  MOVLW  0B
1D1A:  MOVLB  1
1D1C:  MOVWF  x00
1D1E:  MOVLW  61
1D20:  MOVWF  x01
1D22:  MOVLW  6F
1D24:  MOVWF  x02
1D26:  MOVLW  50
1D28:  MOVWF  x03
1D2A:  MOVLW  0D
1D2C:  MOVWF  x04
1D2E:  MOVLW  01
1D30:  MOVWF  x05
1D32:  MOVLW  69
1D34:  MOVWF  x06
1D36:  MOVLW  93
1D38:  MOVWF  x07
1D3A:  MOVLW  F2
1D3C:  MOVWF  x08
1D3E:  MOVLW  7E
1D40:  MOVWF  x09
1D42:  MOVLW  62
1D44:  MOVWF  x0A
1D46:  MOVLW  0F
1D48:  MOVWF  x0B
1D4A:  MOVLW  76
1D4C:  MOVWF  x0C
1D4E:  MOVLW  AE
1D50:  MOVWF  x0D
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
1D52:  MOVFF  E3,111
1D56:  MOVFF  E2,110
1D5A:  MOVFF  E1,10F
1D5E:  MOVFF  E0,10E
1D62:  CLRF   x15
1D64:  CLRF   x14
1D66:  CLRF   x13
1D68:  CLRF   x12
1D6A:  MOVLB  0
1D6C:  RCALL  1C70
1D6E:  BNC   1D76
1D70:  MOVF   xE1,W
1D72:  XORLW  80
1D74:  MOVWF  xE1
1D76:  CLRF   16
1D78:  BTFSC  FF2.7
1D7A:  BSF    16.7
1D7C:  BCF    FF2.7
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
1D7E:  MOVFF  E3,14C
1D82:  MOVFF  E2,14B
1D86:  MOVFF  E1,14A
1D8A:  MOVFF  E0,149
1D8E:  MOVLW  DB
1D90:  MOVLB  1
1D92:  MOVWF  x50
1D94:  MOVLW  0F
1D96:  MOVWF  x4F
1D98:  MOVLW  49
1D9A:  MOVWF  x4E
1D9C:  MOVLW  7F
1D9E:  MOVWF  x4D
1DA0:  MOVLB  0
1DA2:  CALL   02C4
1DA6:  BTFSC  16.7
1DA8:  BSF    FF2.7
1DAA:  MOVFF  03,111
1DAE:  MOVFF  02,110
1DB2:  MOVFF  01,10F
1DB6:  MOVFF  00,10E
1DBA:  RCALL  1724
1DBC:  MOVFF  01,F0
1DC0:  CLRF   16
1DC2:  BTFSC  FF2.7
1DC4:  BSF    16.7
1DC6:  BCF    FF2.7
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
1DC8:  MOVFF  E3,14C
1DCC:  MOVFF  E2,14B
1DD0:  MOVFF  E1,14A
1DD4:  MOVFF  E0,149
1DD8:  MOVLW  DB
1DDA:  MOVLB  1
1DDC:  MOVWF  x50
1DDE:  MOVLW  0F
1DE0:  MOVWF  x4F
1DE2:  MOVLW  49
1DE4:  MOVWF  x4E
1DE6:  MOVLW  7F
1DE8:  MOVWF  x4D
1DEA:  MOVLB  0
1DEC:  CALL   02C4
1DF0:  BTFSC  16.7
1DF2:  BSF    FF2.7
1DF4:  MOVFF  00,10E
1DF8:  MOVFF  01,10F
1DFC:  MOVFF  02,110
1E00:  MOVFF  03,111
1E04:  CLRF   16
1E06:  BTFSC  FF2.7
1E08:  BSF    16.7
1E0A:  BCF    FF2.7
1E0C:  MOVLB  1
1E0E:  CLRF   x4A
1E10:  MOVFF  F0,149
1E14:  MOVLB  0
1E16:  CALL   028E
1E1A:  BTFSC  16.7
1E1C:  BSF    FF2.7
1E1E:  BSF    FD8.1
1E20:  CLRF   16
1E22:  BTFSC  FF2.7
1E24:  BSF    16.7
1E26:  BCF    FF2.7
1E28:  MOVFF  111,14C
1E2C:  MOVFF  110,14B
1E30:  MOVFF  10F,14A
1E34:  MOVFF  10E,149
1E38:  MOVFF  03,150
1E3C:  MOVFF  02,14F
1E40:  MOVFF  01,14E
1E44:  MOVFF  00,14D
1E48:  CALL   0422
1E4C:  BTFSC  16.7
1E4E:  BSF    FF2.7
1E50:  MOVFF  03,F5
1E54:  MOVFF  02,F4
1E58:  MOVFF  01,F3
1E5C:  MOVFF  00,F2
....................    quad = quad % 4;                    // quadrant (0 to 3) 
1E60:  MOVLW  03
1E62:  ANDWF  xF0,F
....................  
....................    if (quad == 0 || quad == 2) 
1E64:  MOVF   xF0,F
1E66:  BZ    1E6E
1E68:  MOVF   xF0,W
1E6A:  SUBLW  02
1E6C:  BNZ   1EB4
1E6E:  CLRF   16
1E70:  BTFSC  FF2.7
1E72:  BSF    16.7
1E74:  BCF    FF2.7
....................       t = frac * PI_DIV_BY_TWO; 
1E76:  MOVFF  F5,148
1E7A:  MOVFF  F4,147
1E7E:  MOVFF  F3,146
1E82:  MOVFF  F2,145
1E86:  MOVLW  DB
1E88:  MOVLB  1
1E8A:  MOVWF  x4C
1E8C:  MOVLW  0F
1E8E:  MOVWF  x4B
1E90:  MOVLW  49
1E92:  MOVWF  x4A
1E94:  MOVLW  7F
1E96:  MOVWF  x49
1E98:  MOVLB  0
1E9A:  CALL   0198
1E9E:  BTFSC  16.7
1EA0:  BSF    FF2.7
1EA2:  MOVFF  03,EB
1EA6:  MOVFF  02,EA
1EAA:  MOVFF  01,E9
1EAE:  MOVFF  00,E8
....................    else if (quad == 1) 
1EB2:  BRA    1FC2
1EB4:  DECFSZ xF0,W
1EB6:  BRA    1F3E
....................       t = (1-frac) * PI_DIV_BY_TWO; 
1EB8:  BSF    FD8.1
1EBA:  CLRF   16
1EBC:  BTFSC  FF2.7
1EBE:  BSF    16.7
1EC0:  BCF    FF2.7
1EC2:  MOVLB  1
1EC4:  CLRF   x4C
1EC6:  CLRF   x4B
1EC8:  CLRF   x4A
1ECA:  MOVLW  7F
1ECC:  MOVWF  x49
1ECE:  MOVFF  F5,150
1ED2:  MOVFF  F4,14F
1ED6:  MOVFF  F3,14E
1EDA:  MOVFF  F2,14D
1EDE:  MOVLB  0
1EE0:  CALL   0422
1EE4:  BTFSC  16.7
1EE6:  BSF    FF2.7
1EE8:  MOVFF  00,10E
1EEC:  MOVFF  01,10F
1EF0:  MOVFF  02,110
1EF4:  MOVFF  03,111
1EF8:  CLRF   16
1EFA:  BTFSC  FF2.7
1EFC:  BSF    16.7
1EFE:  BCF    FF2.7
1F00:  MOVFF  03,148
1F04:  MOVFF  02,147
1F08:  MOVFF  01,146
1F0C:  MOVFF  00,145
1F10:  MOVLW  DB
1F12:  MOVLB  1
1F14:  MOVWF  x4C
1F16:  MOVLW  0F
1F18:  MOVWF  x4B
1F1A:  MOVLW  49
1F1C:  MOVWF  x4A
1F1E:  MOVLW  7F
1F20:  MOVWF  x49
1F22:  MOVLB  0
1F24:  CALL   0198
1F28:  BTFSC  16.7
1F2A:  BSF    FF2.7
1F2C:  MOVFF  03,EB
1F30:  MOVFF  02,EA
1F34:  MOVFF  01,E9
1F38:  MOVFF  00,E8
....................    else // should be 3 
1F3C:  BRA    1FC2
....................       t = (frac-1) * PI_DIV_BY_TWO; 
1F3E:  BSF    FD8.1
1F40:  CLRF   16
1F42:  BTFSC  FF2.7
1F44:  BSF    16.7
1F46:  BCF    FF2.7
1F48:  MOVFF  F5,14C
1F4C:  MOVFF  F4,14B
1F50:  MOVFF  F3,14A
1F54:  MOVFF  F2,149
1F58:  MOVLB  1
1F5A:  CLRF   x50
1F5C:  CLRF   x4F
1F5E:  CLRF   x4E
1F60:  MOVLW  7F
1F62:  MOVWF  x4D
1F64:  MOVLB  0
1F66:  CALL   0422
1F6A:  BTFSC  16.7
1F6C:  BSF    FF2.7
1F6E:  MOVFF  00,10E
1F72:  MOVFF  01,10F
1F76:  MOVFF  02,110
1F7A:  MOVFF  03,111
1F7E:  CLRF   16
1F80:  BTFSC  FF2.7
1F82:  BSF    16.7
1F84:  BCF    FF2.7
1F86:  MOVFF  03,148
1F8A:  MOVFF  02,147
1F8E:  MOVFF  01,146
1F92:  MOVFF  00,145
1F96:  MOVLW  DB
1F98:  MOVLB  1
1F9A:  MOVWF  x4C
1F9C:  MOVLW  0F
1F9E:  MOVWF  x4B
1FA0:  MOVLW  49
1FA2:  MOVWF  x4A
1FA4:  MOVLW  7F
1FA6:  MOVWF  x49
1FA8:  MOVLB  0
1FAA:  CALL   0198
1FAE:  BTFSC  16.7
1FB0:  BSF    FF2.7
1FB2:  MOVFF  03,EB
1FB6:  MOVFF  02,EA
1FBA:  MOVFF  01,E9
1FBE:  MOVFF  00,E8
....................  
....................    y = 1.0; 
1FC2:  CLRF   xE7
1FC4:  CLRF   xE6
1FC6:  CLRF   xE5
1FC8:  MOVLW  7F
1FCA:  MOVWF  xE4
1FCC:  CLRF   16
1FCE:  BTFSC  FF2.7
1FD0:  BSF    16.7
1FD2:  BCF    FF2.7
....................    t = t * t; 
1FD4:  MOVFF  EB,148
1FD8:  MOVFF  EA,147
1FDC:  MOVFF  E9,146
1FE0:  MOVFF  E8,145
1FE4:  MOVFF  EB,14C
1FE8:  MOVFF  EA,14B
1FEC:  MOVFF  E9,14A
1FF0:  MOVFF  E8,149
1FF4:  CALL   0198
1FF8:  BTFSC  16.7
1FFA:  BSF    FF2.7
1FFC:  MOVFF  03,EB
2000:  MOVFF  02,EA
2004:  MOVFF  01,E9
2008:  MOVFF  00,E8
....................    for (i = 0; i <= 5; i++) 
200C:  CLRF   xF1
200E:  MOVF   xF1,W
2010:  SUBLW  05
2012:  BNC   20FC
2014:  CLRF   16
2016:  BTFSC  FF2.7
2018:  BSF    16.7
201A:  BCF    FF2.7
....................    { 
....................       t2 = t2 * t; 
201C:  MOVFF  EF,148
2020:  MOVFF  EE,147
2024:  MOVFF  ED,146
2028:  MOVFF  EC,145
202C:  MOVFF  EB,14C
2030:  MOVFF  EA,14B
2034:  MOVFF  E9,14A
2038:  MOVFF  E8,149
203C:  CALL   0198
2040:  BTFSC  16.7
2042:  BSF    FF2.7
2044:  MOVFF  03,EF
2048:  MOVFF  02,EE
204C:  MOVFF  01,ED
2050:  MOVFF  00,EC
....................       y = y + p[i] * t2; 
2054:  MOVF   xF1,W
2056:  MULLW  04
2058:  MOVF   FF3,W
205A:  CLRF   03
205C:  ADDLW  F6
205E:  MOVWF  FE9
2060:  MOVLW  00
2062:  ADDWFC 03,W
2064:  MOVWF  FEA
2066:  MOVFF  FEF,10E
206A:  MOVFF  FEC,10F
206E:  MOVFF  FEC,110
2072:  MOVFF  FEC,111
2076:  CLRF   16
2078:  BTFSC  FF2.7
207A:  BSF    16.7
207C:  BCF    FF2.7
207E:  MOVFF  111,148
2082:  MOVFF  110,147
2086:  MOVFF  10F,146
208A:  MOVFF  10E,145
208E:  MOVFF  EF,14C
2092:  MOVFF  EE,14B
2096:  MOVFF  ED,14A
209A:  MOVFF  EC,149
209E:  CALL   0198
20A2:  BTFSC  16.7
20A4:  BSF    FF2.7
20A6:  MOVFF  FEA,10F
20AA:  MOVFF  FE9,10E
20AE:  BCF    FD8.1
20B0:  CLRF   16
20B2:  BTFSC  FF2.7
20B4:  BSF    16.7
20B6:  BCF    FF2.7
20B8:  MOVFF  E7,14C
20BC:  MOVFF  E6,14B
20C0:  MOVFF  E5,14A
20C4:  MOVFF  E4,149
20C8:  MOVFF  03,150
20CC:  MOVFF  02,14F
20D0:  MOVFF  01,14E
20D4:  MOVFF  00,14D
20D8:  CALL   0422
20DC:  BTFSC  16.7
20DE:  BSF    FF2.7
20E0:  MOVFF  10F,FEA
20E4:  MOVFF  10E,FE9
20E8:  MOVFF  03,E7
20EC:  MOVFF  02,E6
20F0:  MOVFF  01,E5
20F4:  MOVFF  00,E4
....................    } 
20F8:  INCF   xF1,F
20FA:  BRA    200E
....................  
....................    if (quad == 2 || quad == 1) 
20FC:  MOVF   xF0,W
20FE:  SUBLW  02
2100:  BZ    2106
2102:  DECFSZ xF0,W
2104:  BRA    210C
....................       y = -y;  // correct sign 
2106:  MOVF   xE5,W
2108:  XORLW  80
210A:  MOVWF  xE5
....................  
....................    return (y); 
210C:  MOVFF  E4,00
2110:  MOVFF  E5,01
2114:  MOVFF  E6,02
2118:  MOVFF  E7,03
.................... } 
211C:  RETLW  00
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
211E:  BSF    FD8.1
2120:  CLRF   16
2122:  BTFSC  FF2.7
2124:  BSF    16.7
2126:  BCF    FF2.7
2128:  MOVFF  DB,14C
212C:  MOVFF  DA,14B
2130:  MOVFF  D9,14A
2134:  MOVFF  D8,149
2138:  MOVLW  DB
213A:  MOVLB  1
213C:  MOVWF  x50
213E:  MOVLW  0F
2140:  MOVWF  x4F
2142:  MOVLW  49
2144:  MOVWF  x4E
2146:  MOVLW  7F
2148:  MOVWF  x4D
214A:  MOVLB  0
214C:  CALL   0422
2150:  BTFSC  16.7
2152:  BSF    FF2.7
2154:  MOVFF  00,DC
2158:  MOVFF  01,DD
215C:  MOVFF  02,DE
2160:  MOVFF  03,DF
2164:  MOVFF  03,E3
2168:  MOVFF  02,E2
216C:  MOVFF  01,E1
2170:  MOVFF  00,E0
2174:  RCALL  1CEA
.................... } 
2176:  GOTO   2328 (RETURN)
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... #include <string.h> 
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #use delay(clock=20000000) 
.................... #use rs232(uart1,baud=38400,parity=N,Stop=1,bits=8,stream=COM3,errors)//Khai bao su dung uart cung 
*
00BA:  BTFSS  F9E.5
00BC:  BRA    00BA
00BE:  MOVFF  FAB,1D
00C2:  MOVFF  FAE,01
00C6:  BTFSS  1D.1
00C8:  BRA    00CE
00CA:  BCF    FAB.4
00CC:  BSF    FAB.4
00CE:  GOTO   0B54 (RETURN)
00D2:  BTFSS  F9E.4
00D4:  BRA    00D2
00D6:  MOVWF  FAD
00D8:  GOTO   0B94 (RETURN)
.................... #include <string.h>  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... //////////////////// 
.................... //////////////////// 
.................... #use FAST_IO(A) 
.................... #use FAST_IO(D) 
....................  
.................... #byte PORTA =  0xf80 
.................... #byte PORTB =  0xf81 
.................... #byte PORTC =  0xf82 
.................... #byte PORTD =  0xf83 
.................... #byte PORTE =  0xf84 
.................... #BIT RC1 = PORTC.1 
.................... #BIT RC2 = PORTC.2 
.................... #BIT RE0 = PORTE.0 
.................... #BIT RE2 = PORTE.2 
.................... //////////////// 
.................... #define DIR_RIGHT RE0 
.................... #define DIR_LEFT RE2 
.................... #define B RC2 // left ccp2 
.................... #define A RC1 // right cpp1 
.................... //////////////////// 
.................... //khoi tao gia tri ban dau 
....................  
.................... #define time_step 50535  // 0.005 sencond  5535 // 
.................... #define CHUVI_LEFT 345 /// chu vi 
.................... #define CHUVI_RIGHT 345 
.................... #define RADIUS 150   //DO RONG XE/2 
.................... #define nguong_right 1000 //nguong PWM 
.................... #define nguong_left 1000  //two wheels speed 
.................... #define ERR 40 
.................... //////////////////////// 
.................... signed int32 num_pulse_right = 0, count_left = 0; 
.................... signed int32 num_pulse_left = 0; 
.................... // 
....................  
.................... float x_cur = 0, y_cur = 0, x_cur_old = 0, y_cur_old = 0; 
.................... char  huong=""; 
.................... ///TIMER 
.................... int1 done_Timer1 = 0; 
.................... ///// 
.................... /// PWM 
.................... signed int16 pw_duty_left = 0, pw_duty_right = 0; 
.................... /// VITRI 
.................... signed int32 position_right = 0, position_set_right = 0, position_left = 0, position_set_left = 0; // VI TRI DOC DUOC, VI TRI SET GIA TRI  
.................... //CO 
.................... int1  hoanthanhpid = 0 ,copid_right = 0, copid_left = 0,codoctinhieu=0,donePID = 0; 
.................... //// 
.................... float value,value_cmd,anpha = 0; 
.................... float angle_current = 90.0; 
.................... ///PID 
.................... float Kp_r=90, Kd_r=9, Ki_r=0.00001; 
.................... float Kp_l=90, Kd_l=9, Ki_l=0.00001; 
.................... signed int32 e_sum_r=0, e_del_r=0, e1_r=0, e2_r=0; 
.................... signed int32 e_sum_l=0, e_del_l=0, e1_l=0, e2_l=0; 
.................... //// 
.................... char  ss; 
.................... char data_receive[50] = ""; 
.................... int8 index = 0; 
.................... ////// CAC HAM 
.................... //void intpid_right(); 
.................... //void intpid_left(); 
.................... void pid_left(); 
.................... void pid_right(); 
.................... void pid_robot(); 
.................... void xy_vitri(float khoangcach); 
.................... void dichuyen(char huong_move, float value); 
.................... ///////////// 
.................... ////////////////RS232 
....................  
.................... #INT_RDA 
.................... void RDA_isr() 
.................... { 
.................... char value[20]; 
.................... ss=getc(); 
*
0B50:  GOTO   00BA
0B54:  MOVFF  01,98
....................       if (ss=='A')// begining symbol 
0B58:  MOVF   x98,W
0B5A:  SUBLW  41
0B5C:  BNZ   0B72
....................       { 
....................       index=0; 
0B5E:  CLRF   xCB
....................       *data_receive=""; 
0B60:  CLRF   03
0B62:  MOVLW  99
0B64:  MOVLB  1
0B66:  MOVFF  03,FEA
0B6A:  MOVWF  FE9
0B6C:  CLRF   FEF
....................       } 
....................       else if (ss=='C') 
0B6E:  BRA    0C1C
0B70:  MOVLB  0
0B72:  MOVF   x98,W
0B74:  SUBLW  43
0B76:  BNZ   0C06
....................       { 
....................       data_receive[index++]='\0'; 
0B78:  MOVF   xCB,W
0B7A:  INCF   xCB,F
0B7C:  CLRF   03
0B7E:  ADDLW  99
0B80:  MOVWF  FE9
0B82:  MOVLW  00
0B84:  ADDWFC 03,W
0B86:  MOVWF  FEA
0B88:  CLRF   FEF
....................       huong = data_receive[0]; 
0B8A:  MOVFF  99,3A
....................        putc(huong); 
0B8E:  MOVF   3A,W
0B90:  GOTO   00D2
....................       strncpy(value, data_receive + 1, strlen(data_receive) - 1); 
0B94:  MOVLB  1
0B96:  CLRF   x37
0B98:  MOVLW  99
0B9A:  MOVWF  x36
0B9C:  MOVLB  0
0B9E:  GOTO   00DC
0BA2:  MOVLW  01
0BA4:  SUBWF  01,W
0BA6:  MOVLB  1
0BA8:  MOVWF  x36
0BAA:  MOVLW  01
0BAC:  MOVWF  x38
0BAE:  MOVLW  22
0BB0:  MOVWF  x37
0BB2:  CLRF   x3A
0BB4:  MOVLW  9A
0BB6:  MOVWF  x39
0BB8:  MOVFF  136,13B
0BBC:  MOVLB  0
0BBE:  GOTO   0118
....................       value_cmd=atof(value);     
0BC2:  MOVLW  01
0BC4:  MOVLB  1
0BC6:  MOVWF  x37
0BC8:  MOVLW  22
0BCA:  MOVWF  x36
0BCC:  CLRF   x39
0BCE:  CLRF   x38
0BD0:  MOVLB  0
0BD2:  BRA    069A
0BD4:  MOVFF  03,57
0BD8:  MOVFF  02,56
0BDC:  MOVFF  01,55
0BE0:  MOVFF  00,54
....................        printf("%f",value_cmd);//he 10 
0BE4:  MOVLW  89
0BE6:  MOVWF  FE9
0BE8:  MOVFF  57,139
0BEC:  MOVFF  56,138
0BF0:  MOVFF  55,137
0BF4:  MOVFF  54,136
0BF8:  MOVLW  02
0BFA:  MOVLB  1
0BFC:  MOVWF  x3A
0BFE:  MOVLB  0
0C00:  RCALL  09AC
....................          codoctinhieu= 1; 
0C02:  BSF    3B.4
....................       } 
....................       else data_receive[index++] = ss;  
0C04:  BRA    0C1A
0C06:  MOVF   xCB,W
0C08:  INCF   xCB,F
0C0A:  CLRF   03
0C0C:  ADDLW  99
0C0E:  MOVWF  FE9
0C10:  MOVLW  00
0C12:  ADDWFC 03,W
0C14:  MOVWF  FEA
0C16:  MOVFF  98,FEF
0C1A:  MOVLB  1
.................... } 
.................... /// NGAT NGOAI 
....................  
0C1C:  BCF    F9E.5
0C1E:  MOVLB  0
0C20:  GOTO   0078
.................... #INT_EXT1 
.................... void EXT1_isr() 
.................... { 
....................    disable_interrupts(int_ext1); 
0C24:  BCF    FF0.3
....................    if (input(PIN_D1)==1)//qua chieu duong //A-RB1 B-RD1 
0C26:  BTFSS  F83.1
0C28:  BRA    0C3C
....................      { num_pulse_right++;} 
0C2A:  MOVLW  01
0C2C:  ADDWF  1E,F
0C2E:  BTFSC  FD8.0
0C30:  INCF   1F,F
0C32:  BTFSC  FD8.2
0C34:  INCF   20,F
0C36:  BTFSC  FD8.2
0C38:  INCF   21,F
....................    else {num_pulse_right--;} 
0C3A:  BRA    0C4C
0C3C:  MOVLW  FF
0C3E:  ADDWF  1E,F
0C40:  BTFSS  FD8.0
0C42:  ADDWF  1F,F
0C44:  BTFSS  FD8.0
0C46:  ADDWF  20,F
0C48:  BTFSS  FD8.0
0C4A:  ADDWF  21,F
....................    position_right=num_pulse_right; 
0C4C:  MOVFF  21,43
0C50:  MOVFF  20,42
0C54:  MOVFF  1F,41
0C58:  MOVFF  1E,40
....................    enable_interrupts(int_ext1); 
0C5C:  BSF    FF0.3
.................... } 
0C5E:  BCF    FF0.0
0C60:  GOTO   0078
.................... #INT_EXT2 
.................... void EXT2_isr() 
.................... { 
....................    disable_interrupts(int_ext2); 
0C64:  BCF    FF0.4
....................    if (input(PIN_D2)==1) 
0C66:  BTFSS  F83.2
0C68:  BRA    0C98
....................    { 
....................    num_pulse_left++; 
0C6A:  MOVLW  01
0C6C:  ADDWF  26,F
0C6E:  BTFSC  FD8.0
0C70:  INCF   27,F
0C72:  BTFSC  FD8.2
0C74:  INCF   28,F
0C76:  BTFSC  FD8.2
0C78:  INCF   29,F
....................    if ((huong=='T')||(huong=='F')) count_left++;// de cho no khi 2 banh cung chay 
0C7A:  MOVF   3A,W
0C7C:  SUBLW  54
0C7E:  BZ    0C86
0C80:  MOVF   3A,W
0C82:  SUBLW  46
0C84:  BNZ   0C96
0C86:  MOVLW  01
0C88:  ADDWF  22,F
0C8A:  BTFSC  FD8.0
0C8C:  INCF   23,F
0C8E:  BTFSC  FD8.2
0C90:  INCF   24,F
0C92:  BTFSC  FD8.2
0C94:  INCF   25,F
....................    } 
....................    else  
0C96:  BRA    0CC4
....................    { 
....................    num_pulse_left--; 
0C98:  MOVLW  FF
0C9A:  ADDWF  26,F
0C9C:  BTFSS  FD8.0
0C9E:  ADDWF  27,F
0CA0:  BTFSS  FD8.0
0CA2:  ADDWF  28,F
0CA4:  BTFSS  FD8.0
0CA6:  ADDWF  29,F
....................    if ((huong=='T')||(huong=='F')) count_left--; 
0CA8:  MOVF   3A,W
0CAA:  SUBLW  54
0CAC:  BZ    0CB4
0CAE:  MOVF   3A,W
0CB0:  SUBLW  46
0CB2:  BNZ   0CC4
0CB4:  MOVLW  FF
0CB6:  ADDWF  22,F
0CB8:  BTFSS  FD8.0
0CBA:  ADDWF  23,F
0CBC:  BTFSS  FD8.0
0CBE:  ADDWF  24,F
0CC0:  BTFSS  FD8.0
0CC2:  ADDWF  25,F
....................    } 
....................    position_left=num_pulse_left; 
0CC4:  MOVFF  29,4B
0CC8:  MOVFF  28,4A
0CCC:  MOVFF  27,49
0CD0:  MOVFF  26,48
....................    enable_interrupts(int_ext2); 
0CD4:  BSF    FF0.4
.................... } 
0CD6:  BCF    FF0.1
0CD8:  GOTO   0078
.................... #INT_TIMER1 
.................... void TIMER1_isr() 
.................... { 
....................       done_Timer1 = 1; 
0CDC:  BSF    3B.0
....................       set_timer1(time_step); 
0CDE:  MOVLW  C5
0CE0:  MOVWF  FCF
0CE2:  MOVLW  67
0CE4:  MOVWF  FCE
.................... } 
0CE6:  BCF    F9E.0
0CE8:  GOTO   0078
.................... void main() 
.................... { 
*
2730:  CLRF   FF8
2732:  BCF    FD0.7
2734:  BSF    07.7
2736:  CLRF   FEA
2738:  CLRF   FE9
273A:  BSF    FB8.3
273C:  MOVLW  81
273E:  MOVWF  FAF
2740:  MOVLW  00
2742:  MOVWF  FB0
2744:  MOVLW  A6
2746:  MOVWF  FAC
2748:  MOVLW  90
274A:  MOVWF  FAB
274C:  CLRF   21
274E:  CLRF   20
2750:  CLRF   1F
2752:  CLRF   1E
2754:  CLRF   25
2756:  CLRF   24
2758:  CLRF   23
275A:  CLRF   22
275C:  CLRF   29
275E:  CLRF   28
2760:  CLRF   27
2762:  CLRF   26
2764:  CLRF   2D
2766:  CLRF   2C
2768:  CLRF   2B
276A:  CLRF   2A
276C:  CLRF   31
276E:  CLRF   30
2770:  CLRF   2F
2772:  CLRF   2E
2774:  CLRF   35
2776:  CLRF   34
2778:  CLRF   33
277A:  CLRF   32
277C:  CLRF   39
277E:  CLRF   38
2780:  CLRF   37
2782:  CLRF   36
2784:  CLRF   3A
2786:  BCF    3B.0
2788:  CLRF   3D
278A:  CLRF   3C
278C:  CLRF   3F
278E:  CLRF   3E
2790:  CLRF   43
2792:  CLRF   42
2794:  CLRF   41
2796:  CLRF   40
2798:  CLRF   47
279A:  CLRF   46
279C:  CLRF   45
279E:  CLRF   44
27A0:  CLRF   4B
27A2:  CLRF   4A
27A4:  CLRF   49
27A6:  CLRF   48
27A8:  CLRF   4F
27AA:  CLRF   4E
27AC:  CLRF   4D
27AE:  CLRF   4C
27B0:  BCF    3B.1
27B2:  BCF    3B.2
27B4:  BCF    3B.3
27B6:  BCF    3B.4
27B8:  BCF    3B.5
27BA:  CLRF   5B
27BC:  CLRF   5A
27BE:  CLRF   59
27C0:  CLRF   58
27C2:  CLRF   5F
27C4:  CLRF   5E
27C6:  MOVLW  34
27C8:  MOVWF  5D
27CA:  MOVLW  85
27CC:  MOVWF  5C
27CE:  CLRF   x63
27D0:  CLRF   x62
27D2:  MOVLW  34
27D4:  MOVWF  x61
27D6:  MOVLW  85
27D8:  MOVWF  x60
27DA:  CLRF   x67
27DC:  CLRF   x66
27DE:  MOVLW  10
27E0:  MOVWF  x65
27E2:  MOVLW  82
27E4:  MOVWF  x64
27E6:  MOVLW  AC
27E8:  MOVWF  x6B
27EA:  MOVLW  C5
27EC:  MOVWF  x6A
27EE:  MOVLW  27
27F0:  MOVWF  x69
27F2:  MOVLW  6E
27F4:  MOVWF  x68
27F6:  CLRF   x6F
27F8:  CLRF   x6E
27FA:  MOVLW  34
27FC:  MOVWF  x6D
27FE:  MOVLW  85
2800:  MOVWF  x6C
2802:  CLRF   x73
2804:  CLRF   x72
2806:  MOVLW  10
2808:  MOVWF  x71
280A:  MOVLW  82
280C:  MOVWF  x70
280E:  MOVLW  AC
2810:  MOVWF  x77
2812:  MOVLW  C5
2814:  MOVWF  x76
2816:  MOVLW  27
2818:  MOVWF  x75
281A:  MOVLW  6E
281C:  MOVWF  x74
281E:  CLRF   x7B
2820:  CLRF   x7A
2822:  CLRF   x79
2824:  CLRF   x78
2826:  CLRF   x7F
2828:  CLRF   x7E
282A:  CLRF   x7D
282C:  CLRF   x7C
282E:  CLRF   x83
2830:  CLRF   x82
2832:  CLRF   x81
2834:  CLRF   x80
2836:  CLRF   x87
2838:  CLRF   x86
283A:  CLRF   x85
283C:  CLRF   x84
283E:  CLRF   x8B
2840:  CLRF   x8A
2842:  CLRF   x89
2844:  CLRF   x88
2846:  CLRF   x8F
2848:  CLRF   x8E
284A:  CLRF   x8D
284C:  CLRF   x8C
284E:  CLRF   x93
2850:  CLRF   x92
2852:  CLRF   x91
2854:  CLRF   x90
2856:  CLRF   x97
2858:  CLRF   x96
285A:  CLRF   x95
285C:  CLRF   x94
285E:  CLRF   xCB
2860:  MOVF   FC1,W
2862:  ANDLW  C0
2864:  IORLW  0F
2866:  MOVWF  FC1
2868:  MOVLW  07
286A:  MOVWF  FB4
286C:  CLRF   17
286E:  CLRF   18
2870:  CLRF   1D
2872:  CLRF   x99
....................       set_tris_a(0); 
2874:  MOVLW  00
2876:  MOVWF  F92
....................        set_tris_b(0xFF); 
2878:  MOVLW  FF
287A:  MOVWF  F93
....................        set_tris_e(0); 
287C:  MOVLW  00
287E:  MOVWF  F96
....................        set_tris_c(0x80); 
2880:  MOVLW  80
2882:  MOVWF  F94
....................        set_tris_d(0x0F); 
2884:  MOVLW  0F
2886:  MOVWF  F95
....................        DIR_RIGHT = 0;  //right wheel forward 
2888:  BCF    F84.0
....................        DIR_LEFT = 0; 
288A:  BCF    F84.2
....................        
....................        setup_adc_ports(NO_ANALOGS); 
288C:  MOVF   FC1,W
288E:  ANDLW  C0
2890:  IORLW  0F
2892:  MOVWF  FC1
....................        setup_timer_1(T1_INTERNAL | T1_DIV_BY_1 ); 
2894:  MOVLW  85
2896:  MOVWF  FCD
....................        set_timer1(time_step);   
2898:  MOVLW  C5
289A:  MOVWF  FCF
289C:  MOVLW  67
289E:  MOVWF  FCE
....................        setup_timer_2(T2_DIV_BY_4,255,1);  //f_pwm = 2.9 Khz, T_pwm = 4.(PR2+1).Tosc.Pre-scale 
28A0:  MOVLW  00
28A2:  IORLW  05
28A4:  MOVWF  FCA
28A6:  MOVLW  FF
28A8:  MOVWF  FCB
....................        output_low(PIN_C1); // Set CCP2 output low  
28AA:  BCF    F94.1
28AC:  BCF    F8B.1
....................        output_low(PIN_C2); // Set CCP1 output low  
28AE:  BCF    F94.2
28B0:  BCF    F8B.2
....................        
....................        setup_ccp1(CCP_PWM);    //khoi tao bo PWM1 
28B2:  BCF    F94.2
28B4:  BCF    F8B.2
28B6:  BCF    F96.6
28B8:  MOVLW  0C
28BA:  MOVWF  FBD
28BC:  CLRF   FB7
28BE:  CLRF   FB6
....................        setup_ccp2(CCP_PWM);    //khoi tao bo PWM2 
28C0:  BCF    F94.1
28C2:  BCF    F8B.1
28C4:  MOVWF  FBA
....................        set_pwm1_duty(0);      //PIN_C2, Right motor 
28C6:  CLRF   FBE
....................        set_pwm2_duty(0);      //PIN_C1, Left motor 
28C8:  CLRF   FBB
....................         
....................        enable_interrupts(INT_RDA);  
28CA:  BSF    F9D.5
....................        enable_interrupts(int_ext1); 
28CC:  BSF    FF0.3
....................        enable_interrupts(int_ext2); 
28CE:  BSF    FF0.4
....................        ext_int_edge(1, H_TO_L ); 
28D0:  BCF    FF1.5
....................        ext_int_edge(2, H_TO_L ); 
28D2:  BCF    FF1.4
....................        enable_interrupts(INT_TIMER1);    
28D4:  BSF    F9D.0
....................        enable_interrupts(GLOBAL);  
28D6:  MOVLW  C0
28D8:  IORWF  FF2,F
....................           output_low(pin_A0); 
28DA:  BCF    F89.0
....................         A=1; 
28DC:  BSF    F82.1
....................        B=1;     
28DE:  BSF    F82.2
....................        while (true) 
....................        { 
....................        if (done_Timer1) 
28E0:  BTFSS  3B.0
28E2:  BRA    2900
....................        {        
....................        dichuyen(huong,value_cmd); 
28E4:  MOVFF  3A,CC
28E8:  MOVFF  57,D0
28EC:  MOVFF  56,CF
28F0:  MOVFF  55,CE
28F4:  MOVFF  54,CD
28F8:  GOTO   0CEC
....................        pid_robot(); 
28FC:  BRA    2400
....................        done_Timer1=0;        
28FE:  BCF    3B.0
....................        } 
....................        } 
2900:  BRA    28E0
.................... } 
.................... /*void intpid_right() 
.................... { 
.................... Kp_r = 90; 
.................... ki_r = 0.0000001; 
.................... kd_r = 9; 
.................... e_sum_r = 0; 
.................... e_del_r = 0; 
.................... e1_r = 0; 
.................... e2_r = 0; 
.................... pw_duty_Right = 0; 
.................... } 
.................... void intpid_left() 
.................... { 
.................... Kp_l = 90;  //0.9 
.................... ki_l = 0.0000001; 
.................... kd_l =9;      //1 
.................... e_sum_l = 0; 
.................... e_del_l = 0; 
.................... e1_l = 0; 
.................... e2_l = 0; 
.................... pw_duty_Left = 0; 
.................... }*/ 
.................... void pid_right() 
.................... { 
2902:  SLEEP 
.................... A=1; 
*
1760:  BSF    F82.1
....................   signed int16 temp_kp = 0; 
....................   signed int16 temp_ki = 0; 
....................   signed int16 temp_kd = 0; 
....................   signed int16 pw_duty_Right_Temp = 0; 
1762:  CLRF   xCD
1764:  CLRF   xCC
1766:  CLRF   xCF
1768:  CLRF   xCE
176A:  CLRF   xD1
176C:  CLRF   xD0
176E:  CLRF   xD3
1770:  CLRF   xD2
....................   e2_r= position_set_right- position_right; 
1772:  MOVF   40,W
1774:  SUBWF  44,W
1776:  MOVWF  x84
1778:  MOVF   41,W
177A:  SUBWFB 45,W
177C:  MOVWF  x85
177E:  MOVF   42,W
1780:  SUBWFB 46,W
1782:  MOVWF  x86
1784:  MOVF   43,W
1786:  SUBWFB 47,W
1788:  MOVWF  x87
....................   e_sum_r+=e2_r; 
178A:  MOVF   x84,W
178C:  ADDWF  x78,F
178E:  MOVF   x85,W
1790:  ADDWFC x79,F
1792:  MOVF   x86,W
1794:  ADDWFC x7A,F
1796:  MOVF   x87,W
1798:  ADDWFC x7B,F
....................   e_del_r=e2_r-e1_r; 
179A:  MOVF   x80,W
179C:  SUBWF  x84,W
179E:  MOVWF  x7C
17A0:  MOVF   x81,W
17A2:  SUBWFB x85,W
17A4:  MOVWF  x7D
17A6:  MOVF   x82,W
17A8:  SUBWFB x86,W
17AA:  MOVWF  x7E
17AC:  MOVF   x83,W
17AE:  SUBWFB x87,W
17B0:  MOVWF  x7F
....................   e1_r=e2_r; 
17B2:  MOVFF  87,83
17B6:  MOVFF  86,82
17BA:  MOVFF  85,81
17BE:  MOVFF  84,80
....................    temp_kp = (signed int16)((float)kp_r*e2_r); 
17C2:  MOVFF  87,D7
17C6:  MOVFF  86,D6
17CA:  MOVFF  85,D5
17CE:  MOVFF  84,D4
17D2:  RCALL  16CE
17D4:  CLRF   16
17D6:  BTFSC  FF2.7
17D8:  BSF    16.7
17DA:  BCF    FF2.7
17DC:  MOVFF  63,148
17E0:  MOVFF  62,147
17E4:  MOVFF  61,146
17E8:  MOVFF  60,145
17EC:  MOVFF  03,14C
17F0:  MOVFF  02,14B
17F4:  MOVFF  01,14A
17F8:  MOVFF  00,149
17FC:  CALL   0198
1800:  BTFSC  16.7
1802:  BSF    FF2.7
1804:  MOVFF  03,111
1808:  MOVFF  02,110
180C:  MOVFF  01,10F
1810:  MOVFF  00,10E
1814:  RCALL  1724
1816:  MOVFF  02,CD
181A:  MOVFF  01,CC
....................    temp_ki = (signed int16)((float)ki_r*e_sum_r); 
181E:  MOVFF  7B,D7
1822:  MOVFF  7A,D6
1826:  MOVFF  79,D5
182A:  MOVFF  78,D4
182E:  RCALL  16CE
1830:  CLRF   16
1832:  BTFSC  FF2.7
1834:  BSF    16.7
1836:  BCF    FF2.7
1838:  MOVFF  6B,148
183C:  MOVFF  6A,147
1840:  MOVFF  69,146
1844:  MOVFF  68,145
1848:  MOVFF  03,14C
184C:  MOVFF  02,14B
1850:  MOVFF  01,14A
1854:  MOVFF  00,149
1858:  CALL   0198
185C:  BTFSC  16.7
185E:  BSF    FF2.7
1860:  MOVFF  03,111
1864:  MOVFF  02,110
1868:  MOVFF  01,10F
186C:  MOVFF  00,10E
1870:  RCALL  1724
1872:  MOVFF  02,CF
1876:  MOVFF  01,CE
....................    temp_kd = (signed int16)((float)kd_r*e_del_r); 
187A:  MOVFF  7F,D7
187E:  MOVFF  7E,D6
1882:  MOVFF  7D,D5
1886:  MOVFF  7C,D4
188A:  RCALL  16CE
188C:  CLRF   16
188E:  BTFSC  FF2.7
1890:  BSF    16.7
1892:  BCF    FF2.7
1894:  MOVFF  67,148
1898:  MOVFF  66,147
189C:  MOVFF  65,146
18A0:  MOVFF  64,145
18A4:  MOVFF  03,14C
18A8:  MOVFF  02,14B
18AC:  MOVFF  01,14A
18B0:  MOVFF  00,149
18B4:  CALL   0198
18B8:  BTFSC  16.7
18BA:  BSF    FF2.7
18BC:  MOVFF  03,111
18C0:  MOVFF  02,110
18C4:  MOVFF  01,10F
18C8:  MOVFF  00,10E
18CC:  RCALL  1724
18CE:  MOVFF  02,D1
18D2:  MOVFF  01,D0
....................    
....................    pw_duty_Right_Temp = (signed int16)( temp_kp + temp_ki + temp_kd); 
18D6:  MOVF   xCE,W
18D8:  ADDWF  xCC,W
18DA:  MOVWF  xD4
18DC:  MOVF   xCF,W
18DE:  ADDWFC xCD,W
18E0:  MOVWF  xD5
18E2:  MOVF   xD0,W
18E4:  ADDWF  xD4,W
18E6:  MOVWF  xD2
18E8:  MOVF   xD1,W
18EA:  ADDWFC xD5,W
18EC:  MOVWF  xD3
....................    if ( pw_duty_Right_Temp > nguong_right) 
18EE:  BTFSC  xD3.7
18F0:  BRA    190A
18F2:  MOVF   xD3,W
18F4:  SUBLW  02
18F6:  BC    190A
18F8:  XORLW  FF
18FA:  BNZ   1902
18FC:  MOVF   xD2,W
18FE:  SUBLW  E8
1900:  BC    190A
....................    { 
....................    pw_duty_Right_Temp=nguong_right; 
1902:  MOVLW  03
1904:  MOVWF  xD3
1906:  MOVLW  E8
1908:  MOVWF  xD2
....................    } 
....................    if (pw_duty_Right_Temp < -nguong_right) 
190A:  BTFSS  xD3.7
190C:  BRA    1924
190E:  MOVF   xD3,W
1910:  SUBLW  FC
1912:  BNC   1924
1914:  BNZ   191C
1916:  MOVF   xD2,W
1918:  SUBLW  17
191A:  BNC   1924
....................    { 
....................    pw_duty_Right_Temp=-nguong_right; 
191C:  MOVLW  FC
191E:  MOVWF  xD3
1920:  MOVLW  18
1922:  MOVWF  xD2
....................    } 
....................    if ( pw_duty_Right_Temp>0) 
1924:  BTFSC  xD3.7
1926:  BRA    1964
1928:  MOVF   xD3,F
192A:  BNZ   1932
192C:  MOVF   xD2,W
192E:  SUBLW  00
1930:  BC    1964
....................    { 
....................    DIR_RIGHT=1; 
1932:  BSF    F84.0
....................     pw_duty_Right= pw_duty_Right_Temp; 
1934:  MOVFF  D3,3F
1938:  MOVFF  D2,3E
....................     set_pwm1_duty(pw_duty_Right); 
193C:  MOVFF  3F,02
1940:  MOVFF  3E,01
1944:  RRCF   02,F
1946:  RRCF   01,F
1948:  RRCF   02,F
194A:  RRCF   01,F
194C:  RRCF   02,F
194E:  MOVFF  01,FBE
1952:  RRCF   02,F
1954:  RRCF   02,W
1956:  ANDLW  30
1958:  MOVWF  00
195A:  MOVF   FBD,W
195C:  ANDLW  CF
195E:  IORWF  00,W
1960:  MOVWF  FBD
....................    } 
....................    else  
1962:  BRA    199A
....................    { 
....................     DIR_RIGHT=0; 
1964:  BCF    F84.0
....................     pw_duty_Right= - pw_duty_Right_Temp; 
1966:  COMF   xD2,W
1968:  MOVWF  3E
196A:  COMF   xD3,W
196C:  MOVWF  3F
196E:  INCF   3E,F
1970:  BTFSC  FD8.2
1972:  INCF   3F,F
....................     set_pwm1_duty(pw_duty_Right); 
1974:  MOVFF  3F,02
1978:  MOVFF  3E,01
197C:  RRCF   02,F
197E:  RRCF   01,F
1980:  RRCF   02,F
1982:  RRCF   01,F
1984:  RRCF   02,F
1986:  MOVFF  01,FBE
198A:  RRCF   02,F
198C:  RRCF   02,W
198E:  ANDLW  30
1990:  MOVWF  00
1992:  MOVF   FBD,W
1994:  ANDLW  CF
1996:  IORWF  00,W
1998:  MOVWF  FBD
....................    } 
....................    if((e2_r>-ERR)&&(e2_r<ERR)) 
199A:  BTFSS  x87.7
199C:  BRA    19C2
199E:  MOVF   x87,W
19A0:  SUBLW  FE
19A2:  BC    19E2
19A4:  XORLW  FF
19A6:  BNZ   19C2
19A8:  MOVF   x86,W
19AA:  SUBLW  FE
19AC:  BC    19E2
19AE:  XORLW  FF
19B0:  BNZ   19C2
19B2:  MOVF   x85,W
19B4:  SUBLW  FE
19B6:  BC    19E2
19B8:  XORLW  FF
19BA:  BNZ   19C2
19BC:  MOVF   x84,W
19BE:  SUBLW  D8
19C0:  BC    19E2
19C2:  BTFSC  x87.7
19C4:  BRA    19D8
19C6:  MOVF   x87,F
19C8:  BNZ   19E2
19CA:  MOVF   x86,F
19CC:  BNZ   19E2
19CE:  MOVF   x85,F
19D0:  BNZ   19E2
19D2:  MOVF   x84,W
19D4:  SUBLW  27
19D6:  BNC   19E2
....................    { 
....................      DIR_RIGHT=0; 
19D8:  BCF    F84.0
....................       A=0; 
19DA:  BCF    F82.1
....................       set_pwm1_duty(0); 
19DC:  CLRF   FBE
....................       copid_right=0;// hoan thanh pid 
19DE:  BCF    3B.2
....................    } 
....................    else 
19E0:  BRA    19E4
....................    { 
....................    copid_right=1;//khong hoan thanh pid 
19E2:  BSF    3B.2
....................    } 
.................... } 
19E4:  GOTO   2404 (RETURN)
.................... void pid_left() 
.................... { 
.................... B=1; 
19E8:  BSF    F82.2
....................   signed int16 temp_kp = 0; 
....................   signed int16 temp_ki = 0; 
....................   signed int16 temp_kd = 0; 
....................   signed int16 pw_duty_Left_Temp = 0; 
19EA:  CLRF   xCD
19EC:  CLRF   xCC
19EE:  CLRF   xCF
19F0:  CLRF   xCE
19F2:  CLRF   xD1
19F4:  CLRF   xD0
19F6:  CLRF   xD3
19F8:  CLRF   xD2
....................  
....................   e2_l = position_set_Left - position_Left; 
19FA:  MOVF   48,W
19FC:  SUBWF  4C,W
19FE:  MOVWF  x94
1A00:  MOVF   49,W
1A02:  SUBWFB 4D,W
1A04:  MOVWF  x95
1A06:  MOVF   4A,W
1A08:  SUBWFB 4E,W
1A0A:  MOVWF  x96
1A0C:  MOVF   4B,W
1A0E:  SUBWFB 4F,W
1A10:  MOVWF  x97
....................   e_sum_l += e2_l; 
1A12:  MOVF   x94,W
1A14:  ADDWF  x88,F
1A16:  MOVF   x95,W
1A18:  ADDWFC x89,F
1A1A:  MOVF   x96,W
1A1C:  ADDWFC x8A,F
1A1E:  MOVF   x97,W
1A20:  ADDWFC x8B,F
....................   e_del_l = e2_l - e1_l; 
1A22:  MOVF   x90,W
1A24:  SUBWF  x94,W
1A26:  MOVWF  x8C
1A28:  MOVF   x91,W
1A2A:  SUBWFB x95,W
1A2C:  MOVWF  x8D
1A2E:  MOVF   x92,W
1A30:  SUBWFB x96,W
1A32:  MOVWF  x8E
1A34:  MOVF   x93,W
1A36:  SUBWFB x97,W
1A38:  MOVWF  x8F
....................   e1_l = e2_l; 
1A3A:  MOVFF  97,93
1A3E:  MOVFF  96,92
1A42:  MOVFF  95,91
1A46:  MOVFF  94,90
....................  
....................   temp_kp = (signed int16)((float)kp_l*e2_l); 
1A4A:  MOVFF  97,D7
1A4E:  MOVFF  96,D6
1A52:  MOVFF  95,D5
1A56:  MOVFF  94,D4
1A5A:  RCALL  16CE
1A5C:  CLRF   16
1A5E:  BTFSC  FF2.7
1A60:  BSF    16.7
1A62:  BCF    FF2.7
1A64:  MOVFF  6F,148
1A68:  MOVFF  6E,147
1A6C:  MOVFF  6D,146
1A70:  MOVFF  6C,145
1A74:  MOVFF  03,14C
1A78:  MOVFF  02,14B
1A7C:  MOVFF  01,14A
1A80:  MOVFF  00,149
1A84:  CALL   0198
1A88:  BTFSC  16.7
1A8A:  BSF    FF2.7
1A8C:  MOVFF  03,111
1A90:  MOVFF  02,110
1A94:  MOVFF  01,10F
1A98:  MOVFF  00,10E
1A9C:  RCALL  1724
1A9E:  MOVFF  02,CD
1AA2:  MOVFF  01,CC
....................   temp_ki = (signed int16)((float)ki_l*e_sum_l); 
1AA6:  MOVFF  8B,D7
1AAA:  MOVFF  8A,D6
1AAE:  MOVFF  89,D5
1AB2:  MOVFF  88,D4
1AB6:  RCALL  16CE
1AB8:  CLRF   16
1ABA:  BTFSC  FF2.7
1ABC:  BSF    16.7
1ABE:  BCF    FF2.7
1AC0:  MOVFF  77,148
1AC4:  MOVFF  76,147
1AC8:  MOVFF  75,146
1ACC:  MOVFF  74,145
1AD0:  MOVFF  03,14C
1AD4:  MOVFF  02,14B
1AD8:  MOVFF  01,14A
1ADC:  MOVFF  00,149
1AE0:  CALL   0198
1AE4:  BTFSC  16.7
1AE6:  BSF    FF2.7
1AE8:  MOVFF  03,111
1AEC:  MOVFF  02,110
1AF0:  MOVFF  01,10F
1AF4:  MOVFF  00,10E
1AF8:  RCALL  1724
1AFA:  MOVFF  02,CF
1AFE:  MOVFF  01,CE
....................   temp_kd = (signed int16)((float)kd_l*e_del_l); 
1B02:  MOVFF  8F,D7
1B06:  MOVFF  8E,D6
1B0A:  MOVFF  8D,D5
1B0E:  MOVFF  8C,D4
1B12:  RCALL  16CE
1B14:  CLRF   16
1B16:  BTFSC  FF2.7
1B18:  BSF    16.7
1B1A:  BCF    FF2.7
1B1C:  MOVFF  73,148
1B20:  MOVFF  72,147
1B24:  MOVFF  71,146
1B28:  MOVFF  70,145
1B2C:  MOVFF  03,14C
1B30:  MOVFF  02,14B
1B34:  MOVFF  01,14A
1B38:  MOVFF  00,149
1B3C:  CALL   0198
1B40:  BTFSC  16.7
1B42:  BSF    FF2.7
1B44:  MOVFF  03,111
1B48:  MOVFF  02,110
1B4C:  MOVFF  01,10F
1B50:  MOVFF  00,10E
1B54:  RCALL  1724
1B56:  MOVFF  02,D1
1B5A:  MOVFF  01,D0
....................    
....................   pw_duty_Left_Temp = (signed int16)( temp_kp + temp_ki + temp_kd); 
1B5E:  MOVF   xCE,W
1B60:  ADDWF  xCC,W
1B62:  MOVWF  xD4
1B64:  MOVF   xCF,W
1B66:  ADDWFC xCD,W
1B68:  MOVWF  xD5
1B6A:  MOVF   xD0,W
1B6C:  ADDWF  xD4,W
1B6E:  MOVWF  xD2
1B70:  MOVF   xD1,W
1B72:  ADDWFC xD5,W
1B74:  MOVWF  xD3
....................   if (pw_duty_Left_Temp>nguong_left){pw_duty_Left_Temp=nguong_left;} 
1B76:  BTFSC  xD3.7
1B78:  BRA    1B92
1B7A:  MOVF   xD3,W
1B7C:  SUBLW  02
1B7E:  BC    1B92
1B80:  XORLW  FF
1B82:  BNZ   1B8A
1B84:  MOVF   xD2,W
1B86:  SUBLW  E8
1B88:  BC    1B92
1B8A:  MOVLW  03
1B8C:  MOVWF  xD3
1B8E:  MOVLW  E8
1B90:  MOVWF  xD2
....................   if (pw_duty_Left_Temp<-nguong_left){pw_duty_Left_Temp=-nguong_left;} 
1B92:  BTFSS  xD3.7
1B94:  BRA    1BAC
1B96:  MOVF   xD3,W
1B98:  SUBLW  FC
1B9A:  BNC   1BAC
1B9C:  BNZ   1BA4
1B9E:  MOVF   xD2,W
1BA0:  SUBLW  17
1BA2:  BNC   1BAC
1BA4:  MOVLW  FC
1BA6:  MOVWF  xD3
1BA8:  MOVLW  18
1BAA:  MOVWF  xD2
....................   if (pw_duty_Left_Temp>0) 
1BAC:  BTFSC  xD3.7
1BAE:  BRA    1BEC
1BB0:  MOVF   xD3,F
1BB2:  BNZ   1BBA
1BB4:  MOVF   xD2,W
1BB6:  SUBLW  00
1BB8:  BC    1BEC
....................   { 
....................     
....................   DIR_LEFT=1; 
1BBA:  BSF    F84.2
....................   pw_duty_Left=pw_duty_Left_Temp; 
1BBC:  MOVFF  D3,3D
1BC0:  MOVFF  D2,3C
....................   set_pwm1_duty(  pw_duty_Left);  
1BC4:  MOVFF  3D,02
1BC8:  MOVFF  3C,01
1BCC:  RRCF   02,F
1BCE:  RRCF   01,F
1BD0:  RRCF   02,F
1BD2:  RRCF   01,F
1BD4:  RRCF   02,F
1BD6:  MOVFF  01,FBE
1BDA:  RRCF   02,F
1BDC:  RRCF   02,W
1BDE:  ANDLW  30
1BE0:  MOVWF  00
1BE2:  MOVF   FBD,W
1BE4:  ANDLW  CF
1BE6:  IORWF  00,W
1BE8:  MOVWF  FBD
....................   } 
....................   else 
1BEA:  BRA    1C22
....................   { 
....................   DIR_LEFT=0; 
1BEC:  BCF    F84.2
....................   pw_duty_Left=-pw_duty_Left_Temp; 
1BEE:  COMF   xD2,W
1BF0:  MOVWF  3C
1BF2:  COMF   xD3,W
1BF4:  MOVWF  3D
1BF6:  INCF   3C,F
1BF8:  BTFSC  FD8.2
1BFA:  INCF   3D,F
....................     set_pwm1_duty( pw_duty_Left);  
1BFC:  MOVFF  3D,02
1C00:  MOVFF  3C,01
1C04:  RRCF   02,F
1C06:  RRCF   01,F
1C08:  RRCF   02,F
1C0A:  RRCF   01,F
1C0C:  RRCF   02,F
1C0E:  MOVFF  01,FBE
1C12:  RRCF   02,F
1C14:  RRCF   02,W
1C16:  ANDLW  30
1C18:  MOVWF  00
1C1A:  MOVF   FBD,W
1C1C:  ANDLW  CF
1C1E:  IORWF  00,W
1C20:  MOVWF  FBD
....................   } 
....................   if ((e2_l<ERR)&&(e2_l>-ERR)) 
1C22:  BTFSC  x97.7
1C24:  BRA    1C38
1C26:  MOVF   x97,F
1C28:  BNZ   1C6A
1C2A:  MOVF   x96,F
1C2C:  BNZ   1C6A
1C2E:  MOVF   x95,F
1C30:  BNZ   1C6A
1C32:  MOVF   x94,W
1C34:  SUBLW  27
1C36:  BNC   1C6A
1C38:  BTFSS  x97.7
1C3A:  BRA    1C60
1C3C:  MOVF   x97,W
1C3E:  SUBLW  FE
1C40:  BC    1C6A
1C42:  XORLW  FF
1C44:  BNZ   1C60
1C46:  MOVF   x96,W
1C48:  SUBLW  FE
1C4A:  BC    1C6A
1C4C:  XORLW  FF
1C4E:  BNZ   1C60
1C50:  MOVF   x95,W
1C52:  SUBLW  FE
1C54:  BC    1C6A
1C56:  XORLW  FF
1C58:  BNZ   1C60
1C5A:  MOVF   x94,W
1C5C:  SUBLW  D8
1C5E:  BC    1C6A
....................   { 
....................     DIR_LEFT=0; 
1C60:  BCF    F84.2
....................     B=0; 
1C62:  BCF    F82.2
....................     set_pwm2_duty( 0); 
1C64:  CLRF   FBB
....................   copid_left=0;//hoan thanh 
1C66:  BCF    3B.3
....................   } 
....................   else 
1C68:  BRA    1C6C
....................   { 
....................   copid_left=1;// chua hoan thanh 
1C6A:  BSF    3B.3
....................   } 
....................   
....................  
.................... } 
1C6C:  GOTO   2408 (RETURN)
.................... void dichuyen(char huong_move, float value) 
.................... { 
....................       if (codoctinhieu==1) 
*
0CEC:  BTFSS  3B.4
0CEE:  GOTO   16CA
....................       { 
....................     //  intpid_right(); 
....................      // intpid_left(); 
....................       copid_right=1; 
0CF2:  BSF    3B.2
....................       copid_left=1; 
0CF4:  BSF    3B.3
....................       hoanthanhpid=0; 
0CF6:  BCF    3B.1
....................        
....................       num_pulse_right = 0; 
0CF8:  CLRF   21
0CFA:  CLRF   20
0CFC:  CLRF   1F
0CFE:  CLRF   1E
....................       num_pulse_left = 0; 
0D00:  CLRF   29
0D02:  CLRF   28
0D04:  CLRF   27
0D06:  CLRF   26
....................       position_left = 0; 
0D08:  CLRF   4B
0D0A:  CLRF   4A
0D0C:  CLRF   49
0D0E:  CLRF   48
....................       position_right = 0; 
0D10:  CLRF   43
0D12:  CLRF   42
0D14:  CLRF   41
0D16:  CLRF   40
....................       codoctinhieu=0; 
0D18:  BCF    3B.4
....................       switch (huong_move) 
....................       { 
0D1A:  MOVF   xCC,W
0D1C:  XORLW  54
0D1E:  BZ    0D42
0D20:  XORLW  07
0D22:  BTFSC  FD8.2
0D24:  BRA    0E8E
0D26:  XORLW  15
0D28:  BTFSC  FD8.2
0D2A:  BRA    0FD0
0D2C:  XORLW  04
0D2E:  BTFSC  FD8.2
0D30:  BRA    111C
0D32:  XORLW  10
0D34:  BTFSC  FD8.2
0D36:  BRA    1262
0D38:  XORLW  1E
0D3A:  BTFSC  FD8.2
0D3C:  BRA    149E
0D3E:  GOTO   16C8
....................       case 'T': 
0D42:  CLRF   16
0D44:  BTFSC  FF2.7
0D46:  BSF    16.7
0D48:  BCF    FF2.7
....................       { 
....................          position_set_Left  = (unsigned int32)(100.0*value/CHUVI_LEFT); 
0D4A:  MOVLB  1
0D4C:  CLRF   x48
0D4E:  CLRF   x47
0D50:  MOVLW  48
0D52:  MOVWF  x46
0D54:  MOVLW  85
0D56:  MOVWF  x45
0D58:  MOVFF  D0,14C
0D5C:  MOVFF  CF,14B
0D60:  MOVFF  CE,14A
0D64:  MOVFF  CD,149
0D68:  MOVLB  0
0D6A:  CALL   0198
0D6E:  BTFSC  16.7
0D70:  BSF    FF2.7
0D72:  MOVFF  00,D1
0D76:  MOVFF  01,D2
0D7A:  MOVFF  02,D3
0D7E:  MOVFF  03,D4
0D82:  CLRF   16
0D84:  BTFSC  FF2.7
0D86:  BSF    16.7
0D88:  BCF    FF2.7
0D8A:  MOVFF  03,14C
0D8E:  MOVFF  02,14B
0D92:  MOVFF  01,14A
0D96:  MOVFF  00,149
0D9A:  MOVLB  1
0D9C:  CLRF   x50
0D9E:  MOVLW  80
0DA0:  MOVWF  x4F
0DA2:  MOVLW  2C
0DA4:  MOVWF  x4E
0DA6:  MOVLW  87
0DA8:  MOVWF  x4D
0DAA:  MOVLB  0
0DAC:  CALL   02C4
0DB0:  BTFSC  16.7
0DB2:  BSF    FF2.7
0DB4:  CLRF   16
0DB6:  BTFSC  FF2.7
0DB8:  BSF    16.7
0DBA:  BCF    FF2.7
0DBC:  MOVFF  03,146
0DC0:  MOVFF  02,145
0DC4:  MOVFF  01,144
0DC8:  MOVFF  00,143
0DCC:  RCALL  08EA
0DCE:  BTFSC  16.7
0DD0:  BSF    FF2.7
0DD2:  MOVFF  03,4F
0DD6:  MOVFF  02,4E
0DDA:  MOVFF  01,4D
0DDE:  MOVFF  00,4C
0DE2:  CLRF   16
0DE4:  BTFSC  FF2.7
0DE6:  BSF    16.7
0DE8:  BCF    FF2.7
....................          position_set_Right = (unsigned int32)(100.0*value/CHUVI_RIGHT);   
0DEA:  MOVLB  1
0DEC:  CLRF   x48
0DEE:  CLRF   x47
0DF0:  MOVLW  48
0DF2:  MOVWF  x46
0DF4:  MOVLW  85
0DF6:  MOVWF  x45
0DF8:  MOVFF  D0,14C
0DFC:  MOVFF  CF,14B
0E00:  MOVFF  CE,14A
0E04:  MOVFF  CD,149
0E08:  MOVLB  0
0E0A:  CALL   0198
0E0E:  BTFSC  16.7
0E10:  BSF    FF2.7
0E12:  MOVFF  00,D1
0E16:  MOVFF  01,D2
0E1A:  MOVFF  02,D3
0E1E:  MOVFF  03,D4
0E22:  CLRF   16
0E24:  BTFSC  FF2.7
0E26:  BSF    16.7
0E28:  BCF    FF2.7
0E2A:  MOVFF  03,14C
0E2E:  MOVFF  02,14B
0E32:  MOVFF  01,14A
0E36:  MOVFF  00,149
0E3A:  MOVLB  1
0E3C:  CLRF   x50
0E3E:  MOVLW  80
0E40:  MOVWF  x4F
0E42:  MOVLW  2C
0E44:  MOVWF  x4E
0E46:  MOVLW  87
0E48:  MOVWF  x4D
0E4A:  MOVLB  0
0E4C:  CALL   02C4
0E50:  BTFSC  16.7
0E52:  BSF    FF2.7
0E54:  CLRF   16
0E56:  BTFSC  FF2.7
0E58:  BSF    16.7
0E5A:  BCF    FF2.7
0E5C:  MOVFF  03,146
0E60:  MOVFF  02,145
0E64:  MOVFF  01,144
0E68:  MOVFF  00,143
0E6C:  RCALL  08EA
0E6E:  BTFSC  16.7
0E70:  BSF    FF2.7
0E72:  MOVFF  03,47
0E76:  MOVFF  02,46
0E7A:  MOVFF  01,45
0E7E:  MOVFF  00,44
....................           count_left = 0; 
0E82:  CLRF   25
0E84:  CLRF   24
0E86:  CLRF   23
0E88:  CLRF   22
....................          break; 
0E8A:  GOTO   16CA
....................       } 
....................       case 'S': 
0E8E:  CLRF   16
0E90:  BTFSC  FF2.7
0E92:  BSF    16.7
0E94:  BCF    FF2.7
....................       { 
....................           position_set_Left  = (unsigned int32)(100.0*value/CHUVI_LEFT); 
0E96:  MOVLB  1
0E98:  CLRF   x48
0E9A:  CLRF   x47
0E9C:  MOVLW  48
0E9E:  MOVWF  x46
0EA0:  MOVLW  85
0EA2:  MOVWF  x45
0EA4:  MOVFF  D0,14C
0EA8:  MOVFF  CF,14B
0EAC:  MOVFF  CE,14A
0EB0:  MOVFF  CD,149
0EB4:  MOVLB  0
0EB6:  CALL   0198
0EBA:  BTFSC  16.7
0EBC:  BSF    FF2.7
0EBE:  MOVFF  00,D1
0EC2:  MOVFF  01,D2
0EC6:  MOVFF  02,D3
0ECA:  MOVFF  03,D4
0ECE:  CLRF   16
0ED0:  BTFSC  FF2.7
0ED2:  BSF    16.7
0ED4:  BCF    FF2.7
0ED6:  MOVFF  03,14C
0EDA:  MOVFF  02,14B
0EDE:  MOVFF  01,14A
0EE2:  MOVFF  00,149
0EE6:  MOVLB  1
0EE8:  CLRF   x50
0EEA:  MOVLW  80
0EEC:  MOVWF  x4F
0EEE:  MOVLW  2C
0EF0:  MOVWF  x4E
0EF2:  MOVLW  87
0EF4:  MOVWF  x4D
0EF6:  MOVLB  0
0EF8:  CALL   02C4
0EFC:  BTFSC  16.7
0EFE:  BSF    FF2.7
0F00:  CLRF   16
0F02:  BTFSC  FF2.7
0F04:  BSF    16.7
0F06:  BCF    FF2.7
0F08:  MOVFF  03,146
0F0C:  MOVFF  02,145
0F10:  MOVFF  01,144
0F14:  MOVFF  00,143
0F18:  RCALL  08EA
0F1A:  BTFSC  16.7
0F1C:  BSF    FF2.7
0F1E:  MOVFF  03,4F
0F22:  MOVFF  02,4E
0F26:  MOVFF  01,4D
0F2A:  MOVFF  00,4C
0F2E:  CLRF   16
0F30:  BTFSC  FF2.7
0F32:  BSF    16.7
0F34:  BCF    FF2.7
....................           position_set_Right = (unsigned int32)(100.0*value/CHUVI_RIGHT); 
0F36:  MOVLB  1
0F38:  CLRF   x48
0F3A:  CLRF   x47
0F3C:  MOVLW  48
0F3E:  MOVWF  x46
0F40:  MOVLW  85
0F42:  MOVWF  x45
0F44:  MOVFF  D0,14C
0F48:  MOVFF  CF,14B
0F4C:  MOVFF  CE,14A
0F50:  MOVFF  CD,149
0F54:  MOVLB  0
0F56:  CALL   0198
0F5A:  BTFSC  16.7
0F5C:  BSF    FF2.7
0F5E:  MOVFF  00,D1
0F62:  MOVFF  01,D2
0F66:  MOVFF  02,D3
0F6A:  MOVFF  03,D4
0F6E:  CLRF   16
0F70:  BTFSC  FF2.7
0F72:  BSF    16.7
0F74:  BCF    FF2.7
0F76:  MOVFF  03,14C
0F7A:  MOVFF  02,14B
0F7E:  MOVFF  01,14A
0F82:  MOVFF  00,149
0F86:  MOVLB  1
0F88:  CLRF   x50
0F8A:  MOVLW  80
0F8C:  MOVWF  x4F
0F8E:  MOVLW  2C
0F90:  MOVWF  x4E
0F92:  MOVLW  87
0F94:  MOVWF  x4D
0F96:  MOVLB  0
0F98:  CALL   02C4
0F9C:  BTFSC  16.7
0F9E:  BSF    FF2.7
0FA0:  CLRF   16
0FA2:  BTFSC  FF2.7
0FA4:  BSF    16.7
0FA6:  BCF    FF2.7
0FA8:  MOVFF  03,146
0FAC:  MOVFF  02,145
0FB0:  MOVFF  01,144
0FB4:  MOVFF  00,143
0FB8:  RCALL  08EA
0FBA:  BTFSC  16.7
0FBC:  BSF    FF2.7
0FBE:  MOVFF  03,47
0FC2:  MOVFF  02,46
0FC6:  MOVFF  01,45
0FCA:  MOVFF  00,44
....................            break; 
0FCE:  BRA    16CA
....................       } 
....................       case 'F': 
0FD0:  CLRF   16
0FD2:  BTFSC  FF2.7
0FD4:  BSF    16.7
0FD6:  BCF    FF2.7
....................       { 
....................           position_set_Left  = (unsigned int32)(100.0*value/CHUVI_LEFT); 
0FD8:  MOVLB  1
0FDA:  CLRF   x48
0FDC:  CLRF   x47
0FDE:  MOVLW  48
0FE0:  MOVWF  x46
0FE2:  MOVLW  85
0FE4:  MOVWF  x45
0FE6:  MOVFF  D0,14C
0FEA:  MOVFF  CF,14B
0FEE:  MOVFF  CE,14A
0FF2:  MOVFF  CD,149
0FF6:  MOVLB  0
0FF8:  CALL   0198
0FFC:  BTFSC  16.7
0FFE:  BSF    FF2.7
1000:  MOVFF  00,D1
1004:  MOVFF  01,D2
1008:  MOVFF  02,D3
100C:  MOVFF  03,D4
1010:  CLRF   16
1012:  BTFSC  FF2.7
1014:  BSF    16.7
1016:  BCF    FF2.7
1018:  MOVFF  03,14C
101C:  MOVFF  02,14B
1020:  MOVFF  01,14A
1024:  MOVFF  00,149
1028:  MOVLB  1
102A:  CLRF   x50
102C:  MOVLW  80
102E:  MOVWF  x4F
1030:  MOVLW  2C
1032:  MOVWF  x4E
1034:  MOVLW  87
1036:  MOVWF  x4D
1038:  MOVLB  0
103A:  CALL   02C4
103E:  BTFSC  16.7
1040:  BSF    FF2.7
1042:  CLRF   16
1044:  BTFSC  FF2.7
1046:  BSF    16.7
1048:  BCF    FF2.7
104A:  MOVFF  03,146
104E:  MOVFF  02,145
1052:  MOVFF  01,144
1056:  MOVFF  00,143
105A:  RCALL  08EA
105C:  BTFSC  16.7
105E:  BSF    FF2.7
1060:  MOVFF  03,4F
1064:  MOVFF  02,4E
1068:  MOVFF  01,4D
106C:  MOVFF  00,4C
1070:  CLRF   16
1072:  BTFSC  FF2.7
1074:  BSF    16.7
1076:  BCF    FF2.7
....................           position_set_Right = (unsigned int32)(100.0*value/CHUVI_RIGHT);   
1078:  MOVLB  1
107A:  CLRF   x48
107C:  CLRF   x47
107E:  MOVLW  48
1080:  MOVWF  x46
1082:  MOVLW  85
1084:  MOVWF  x45
1086:  MOVFF  D0,14C
108A:  MOVFF  CF,14B
108E:  MOVFF  CE,14A
1092:  MOVFF  CD,149
1096:  MOVLB  0
1098:  CALL   0198
109C:  BTFSC  16.7
109E:  BSF    FF2.7
10A0:  MOVFF  00,D1
10A4:  MOVFF  01,D2
10A8:  MOVFF  02,D3
10AC:  MOVFF  03,D4
10B0:  CLRF   16
10B2:  BTFSC  FF2.7
10B4:  BSF    16.7
10B6:  BCF    FF2.7
10B8:  MOVFF  03,14C
10BC:  MOVFF  02,14B
10C0:  MOVFF  01,14A
10C4:  MOVFF  00,149
10C8:  MOVLB  1
10CA:  CLRF   x50
10CC:  MOVLW  80
10CE:  MOVWF  x4F
10D0:  MOVLW  2C
10D2:  MOVWF  x4E
10D4:  MOVLW  87
10D6:  MOVWF  x4D
10D8:  MOVLB  0
10DA:  CALL   02C4
10DE:  BTFSC  16.7
10E0:  BSF    FF2.7
10E2:  CLRF   16
10E4:  BTFSC  FF2.7
10E6:  BSF    16.7
10E8:  BCF    FF2.7
10EA:  MOVFF  03,146
10EE:  MOVFF  02,145
10F2:  MOVFF  01,144
10F6:  MOVFF  00,143
10FA:  CALL   08EA
10FE:  BTFSC  16.7
1100:  BSF    FF2.7
1102:  MOVFF  03,47
1106:  MOVFF  02,46
110A:  MOVFF  01,45
110E:  MOVFF  00,44
....................           count_left = 0; 
1112:  CLRF   25
1114:  CLRF   24
1116:  CLRF   23
1118:  CLRF   22
....................           break; 
111A:  BRA    16CA
....................       } 
....................       case 'B': 
111C:  CLRF   16
111E:  BTFSC  FF2.7
1120:  BSF    16.7
1122:  BCF    FF2.7
....................       { 
....................        position_set_Left  =  (unsigned int32)(-100.0*value/CHUVI_LEFT); 
1124:  MOVLB  1
1126:  CLRF   x48
1128:  CLRF   x47
112A:  MOVLW  C8
112C:  MOVWF  x46
112E:  MOVLW  85
1130:  MOVWF  x45
1132:  MOVFF  D0,14C
1136:  MOVFF  CF,14B
113A:  MOVFF  CE,14A
113E:  MOVFF  CD,149
1142:  MOVLB  0
1144:  CALL   0198
1148:  BTFSC  16.7
114A:  BSF    FF2.7
114C:  MOVFF  00,D1
1150:  MOVFF  01,D2
1154:  MOVFF  02,D3
1158:  MOVFF  03,D4
115C:  CLRF   16
115E:  BTFSC  FF2.7
1160:  BSF    16.7
1162:  BCF    FF2.7
1164:  MOVFF  03,14C
1168:  MOVFF  02,14B
116C:  MOVFF  01,14A
1170:  MOVFF  00,149
1174:  MOVLB  1
1176:  CLRF   x50
1178:  MOVLW  80
117A:  MOVWF  x4F
117C:  MOVLW  2C
117E:  MOVWF  x4E
1180:  MOVLW  87
1182:  MOVWF  x4D
1184:  MOVLB  0
1186:  CALL   02C4
118A:  BTFSC  16.7
118C:  BSF    FF2.7
118E:  CLRF   16
1190:  BTFSC  FF2.7
1192:  BSF    16.7
1194:  BCF    FF2.7
1196:  MOVFF  03,146
119A:  MOVFF  02,145
119E:  MOVFF  01,144
11A2:  MOVFF  00,143
11A6:  CALL   08EA
11AA:  BTFSC  16.7
11AC:  BSF    FF2.7
11AE:  MOVFF  03,4F
11B2:  MOVFF  02,4E
11B6:  MOVFF  01,4D
11BA:  MOVFF  00,4C
11BE:  CLRF   16
11C0:  BTFSC  FF2.7
11C2:  BSF    16.7
11C4:  BCF    FF2.7
....................         position_set_Right =  (unsigned int32)(-100.0*value/CHUVI_RIGHT); 
11C6:  MOVLB  1
11C8:  CLRF   x48
11CA:  CLRF   x47
11CC:  MOVLW  C8
11CE:  MOVWF  x46
11D0:  MOVLW  85
11D2:  MOVWF  x45
11D4:  MOVFF  D0,14C
11D8:  MOVFF  CF,14B
11DC:  MOVFF  CE,14A
11E0:  MOVFF  CD,149
11E4:  MOVLB  0
11E6:  CALL   0198
11EA:  BTFSC  16.7
11EC:  BSF    FF2.7
11EE:  MOVFF  00,D1
11F2:  MOVFF  01,D2
11F6:  MOVFF  02,D3
11FA:  MOVFF  03,D4
11FE:  CLRF   16
1200:  BTFSC  FF2.7
1202:  BSF    16.7
1204:  BCF    FF2.7
1206:  MOVFF  03,14C
120A:  MOVFF  02,14B
120E:  MOVFF  01,14A
1212:  MOVFF  00,149
1216:  MOVLB  1
1218:  CLRF   x50
121A:  MOVLW  80
121C:  MOVWF  x4F
121E:  MOVLW  2C
1220:  MOVWF  x4E
1222:  MOVLW  87
1224:  MOVWF  x4D
1226:  MOVLB  0
1228:  CALL   02C4
122C:  BTFSC  16.7
122E:  BSF    FF2.7
1230:  CLRF   16
1232:  BTFSC  FF2.7
1234:  BSF    16.7
1236:  BCF    FF2.7
1238:  MOVFF  03,146
123C:  MOVFF  02,145
1240:  MOVFF  01,144
1244:  MOVFF  00,143
1248:  CALL   08EA
124C:  BTFSC  16.7
124E:  BSF    FF2.7
1250:  MOVFF  03,47
1254:  MOVFF  02,46
1258:  MOVFF  01,45
125C:  MOVFF  00,44
....................         break; 
1260:  BRA    16CA
....................       } 
....................       case 'R': 
....................       { 
....................        anpha = - value*3.1415/180.0; 
1262:  MOVFF  CD,D1
1266:  MOVF   xCE,W
1268:  XORLW  80
126A:  MOVWF  xD2
126C:  MOVFF  CF,D3
1270:  MOVFF  D0,D4
1274:  CLRF   16
1276:  BTFSC  FF2.7
1278:  BSF    16.7
127A:  BCF    FF2.7
127C:  MOVFF  D0,148
1280:  MOVFF  CF,147
1284:  MOVFF  FE8,146
1288:  MOVFF  CD,145
128C:  MOVLW  56
128E:  MOVLB  1
1290:  MOVWF  x4C
1292:  MOVLW  0E
1294:  MOVWF  x4B
1296:  MOVLW  49
1298:  MOVWF  x4A
129A:  MOVLW  80
129C:  MOVWF  x49
129E:  MOVLB  0
12A0:  CALL   0198
12A4:  BTFSC  16.7
12A6:  BSF    FF2.7
12A8:  MOVFF  00,D1
12AC:  MOVFF  01,D2
12B0:  MOVFF  02,D3
12B4:  MOVFF  03,D4
12B8:  CLRF   16
12BA:  BTFSC  FF2.7
12BC:  BSF    16.7
12BE:  BCF    FF2.7
12C0:  MOVFF  03,14C
12C4:  MOVFF  02,14B
12C8:  MOVFF  01,14A
12CC:  MOVFF  00,149
12D0:  MOVLB  1
12D2:  CLRF   x50
12D4:  CLRF   x4F
12D6:  MOVLW  34
12D8:  MOVWF  x4E
12DA:  MOVLW  86
12DC:  MOVWF  x4D
12DE:  MOVLB  0
12E0:  CALL   02C4
12E4:  BTFSC  16.7
12E6:  BSF    FF2.7
12E8:  MOVFF  03,5B
12EC:  MOVFF  02,5A
12F0:  MOVFF  01,59
12F4:  MOVFF  00,58
12F8:  CLRF   16
12FA:  BTFSC  FF2.7
12FC:  BSF    16.7
12FE:  BCF    FF2.7
....................        position_set_Left  =  (unsigned int32)(-100.0*(anpha*RADIUS)/CHUVI_LEFT); 
1300:  MOVFF  5B,148
1304:  MOVFF  5A,147
1308:  MOVFF  59,146
130C:  MOVFF  58,145
1310:  MOVLB  1
1312:  CLRF   x4C
1314:  CLRF   x4B
1316:  MOVLW  16
1318:  MOVWF  x4A
131A:  MOVLW  86
131C:  MOVWF  x49
131E:  MOVLB  0
1320:  CALL   0198
1324:  BTFSC  16.7
1326:  BSF    FF2.7
1328:  CLRF   16
132A:  BTFSC  FF2.7
132C:  BSF    16.7
132E:  BCF    FF2.7
1330:  MOVLB  1
1332:  CLRF   x48
1334:  CLRF   x47
1336:  MOVLW  C8
1338:  MOVWF  x46
133A:  MOVLW  85
133C:  MOVWF  x45
133E:  MOVFF  03,14C
1342:  MOVFF  02,14B
1346:  MOVFF  01,14A
134A:  MOVFF  00,149
134E:  MOVLB  0
1350:  CALL   0198
1354:  BTFSC  16.7
1356:  BSF    FF2.7
1358:  MOVFF  00,D1
135C:  MOVFF  01,D2
1360:  MOVFF  02,D3
1364:  MOVFF  03,D4
1368:  CLRF   16
136A:  BTFSC  FF2.7
136C:  BSF    16.7
136E:  BCF    FF2.7
1370:  MOVFF  03,14C
1374:  MOVFF  02,14B
1378:  MOVFF  01,14A
137C:  MOVFF  00,149
1380:  MOVLB  1
1382:  CLRF   x50
1384:  MOVLW  80
1386:  MOVWF  x4F
1388:  MOVLW  2C
138A:  MOVWF  x4E
138C:  MOVLW  87
138E:  MOVWF  x4D
1390:  MOVLB  0
1392:  CALL   02C4
1396:  BTFSC  16.7
1398:  BSF    FF2.7
139A:  CLRF   16
139C:  BTFSC  FF2.7
139E:  BSF    16.7
13A0:  BCF    FF2.7
13A2:  MOVFF  03,146
13A6:  MOVFF  02,145
13AA:  MOVFF  01,144
13AE:  MOVFF  00,143
13B2:  CALL   08EA
13B6:  BTFSC  16.7
13B8:  BSF    FF2.7
13BA:  MOVFF  03,4F
13BE:  MOVFF  02,4E
13C2:  MOVFF  01,4D
13C6:  MOVFF  00,4C
13CA:  CLRF   16
13CC:  BTFSC  FF2.7
13CE:  BSF    16.7
13D0:  BCF    FF2.7
....................        position_set_Right =  (unsigned int32)(100.0*(anpha*RADIUS)/CHUVI_RIGHT);     
13D2:  MOVFF  5B,148
13D6:  MOVFF  5A,147
13DA:  MOVFF  59,146
13DE:  MOVFF  58,145
13E2:  MOVLB  1
13E4:  CLRF   x4C
13E6:  CLRF   x4B
13E8:  MOVLW  16
13EA:  MOVWF  x4A
13EC:  MOVLW  86
13EE:  MOVWF  x49
13F0:  MOVLB  0
13F2:  CALL   0198
13F6:  BTFSC  16.7
13F8:  BSF    FF2.7
13FA:  CLRF   16
13FC:  BTFSC  FF2.7
13FE:  BSF    16.7
1400:  BCF    FF2.7
1402:  MOVLB  1
1404:  CLRF   x48
1406:  CLRF   x47
1408:  MOVLW  48
140A:  MOVWF  x46
140C:  MOVLW  85
140E:  MOVWF  x45
1410:  MOVFF  03,14C
1414:  MOVFF  02,14B
1418:  MOVFF  01,14A
141C:  MOVFF  00,149
1420:  MOVLB  0
1422:  CALL   0198
1426:  BTFSC  16.7
1428:  BSF    FF2.7
142A:  MOVFF  00,D1
142E:  MOVFF  01,D2
1432:  MOVFF  02,D3
1436:  MOVFF  03,D4
143A:  CLRF   16
143C:  BTFSC  FF2.7
143E:  BSF    16.7
1440:  BCF    FF2.7
1442:  MOVFF  03,14C
1446:  MOVFF  02,14B
144A:  MOVFF  01,14A
144E:  MOVFF  00,149
1452:  MOVLB  1
1454:  CLRF   x50
1456:  MOVLW  80
1458:  MOVWF  x4F
145A:  MOVLW  2C
145C:  MOVWF  x4E
145E:  MOVLW  87
1460:  MOVWF  x4D
1462:  MOVLB  0
1464:  CALL   02C4
1468:  BTFSC  16.7
146A:  BSF    FF2.7
146C:  CLRF   16
146E:  BTFSC  FF2.7
1470:  BSF    16.7
1472:  BCF    FF2.7
1474:  MOVFF  03,146
1478:  MOVFF  02,145
147C:  MOVFF  01,144
1480:  MOVFF  00,143
1484:  CALL   08EA
1488:  BTFSC  16.7
148A:  BSF    FF2.7
148C:  MOVFF  03,47
1490:  MOVFF  02,46
1494:  MOVFF  01,45
1498:  MOVFF  00,44
....................         break; 
149C:  BRA    16CA
....................       } 
....................       case 'L': 
149E:  CLRF   16
14A0:  BTFSC  FF2.7
14A2:  BSF    16.7
14A4:  BCF    FF2.7
....................       { 
....................         anpha = value*3.1415/180.0;      
14A6:  MOVFF  D0,148
14AA:  MOVFF  CF,147
14AE:  MOVFF  CE,146
14B2:  MOVFF  CD,145
14B6:  MOVLW  56
14B8:  MOVLB  1
14BA:  MOVWF  x4C
14BC:  MOVLW  0E
14BE:  MOVWF  x4B
14C0:  MOVLW  49
14C2:  MOVWF  x4A
14C4:  MOVLW  80
14C6:  MOVWF  x49
14C8:  MOVLB  0
14CA:  CALL   0198
14CE:  BTFSC  16.7
14D0:  BSF    FF2.7
14D2:  MOVFF  00,D1
14D6:  MOVFF  01,D2
14DA:  MOVFF  02,D3
14DE:  MOVFF  03,D4
14E2:  CLRF   16
14E4:  BTFSC  FF2.7
14E6:  BSF    16.7
14E8:  BCF    FF2.7
14EA:  MOVFF  03,14C
14EE:  MOVFF  02,14B
14F2:  MOVFF  01,14A
14F6:  MOVFF  00,149
14FA:  MOVLB  1
14FC:  CLRF   x50
14FE:  CLRF   x4F
1500:  MOVLW  34
1502:  MOVWF  x4E
1504:  MOVLW  86
1506:  MOVWF  x4D
1508:  MOVLB  0
150A:  CALL   02C4
150E:  BTFSC  16.7
1510:  BSF    FF2.7
1512:  MOVFF  03,5B
1516:  MOVFF  02,5A
151A:  MOVFF  01,59
151E:  MOVFF  00,58
1522:  CLRF   16
1524:  BTFSC  FF2.7
1526:  BSF    16.7
1528:  BCF    FF2.7
....................         position_set_Left  =  (unsigned int32)(-100.0*(anpha*RADIUS)/CHUVI_LEFT);//so xung doc encorder 
152A:  MOVFF  5B,148
152E:  MOVFF  5A,147
1532:  MOVFF  59,146
1536:  MOVFF  58,145
153A:  MOVLB  1
153C:  CLRF   x4C
153E:  CLRF   x4B
1540:  MOVLW  16
1542:  MOVWF  x4A
1544:  MOVLW  86
1546:  MOVWF  x49
1548:  MOVLB  0
154A:  CALL   0198
154E:  BTFSC  16.7
1550:  BSF    FF2.7
1552:  CLRF   16
1554:  BTFSC  FF2.7
1556:  BSF    16.7
1558:  BCF    FF2.7
155A:  MOVLB  1
155C:  CLRF   x48
155E:  CLRF   x47
1560:  MOVLW  C8
1562:  MOVWF  x46
1564:  MOVLW  85
1566:  MOVWF  x45
1568:  MOVFF  03,14C
156C:  MOVFF  02,14B
1570:  MOVFF  01,14A
1574:  MOVFF  00,149
1578:  MOVLB  0
157A:  CALL   0198
157E:  BTFSC  16.7
1580:  BSF    FF2.7
1582:  MOVFF  00,D1
1586:  MOVFF  01,D2
158A:  MOVFF  02,D3
158E:  MOVFF  03,D4
1592:  CLRF   16
1594:  BTFSC  FF2.7
1596:  BSF    16.7
1598:  BCF    FF2.7
159A:  MOVFF  03,14C
159E:  MOVFF  02,14B
15A2:  MOVFF  01,14A
15A6:  MOVFF  00,149
15AA:  MOVLB  1
15AC:  CLRF   x50
15AE:  MOVLW  80
15B0:  MOVWF  x4F
15B2:  MOVLW  2C
15B4:  MOVWF  x4E
15B6:  MOVLW  87
15B8:  MOVWF  x4D
15BA:  MOVLB  0
15BC:  CALL   02C4
15C0:  BTFSC  16.7
15C2:  BSF    FF2.7
15C4:  CLRF   16
15C6:  BTFSC  FF2.7
15C8:  BSF    16.7
15CA:  BCF    FF2.7
15CC:  MOVFF  03,146
15D0:  MOVFF  02,145
15D4:  MOVFF  01,144
15D8:  MOVFF  00,143
15DC:  CALL   08EA
15E0:  BTFSC  16.7
15E2:  BSF    FF2.7
15E4:  MOVFF  03,4F
15E8:  MOVFF  02,4E
15EC:  MOVFF  01,4D
15F0:  MOVFF  00,4C
15F4:  CLRF   16
15F6:  BTFSC  FF2.7
15F8:  BSF    16.7
15FA:  BCF    FF2.7
....................         position_set_Right =  (unsigned int32)(100.0*(anpha*RADIUS)/CHUVI_RIGHT); 
15FC:  MOVFF  5B,148
1600:  MOVFF  5A,147
1604:  MOVFF  59,146
1608:  MOVFF  58,145
160C:  MOVLB  1
160E:  CLRF   x4C
1610:  CLRF   x4B
1612:  MOVLW  16
1614:  MOVWF  x4A
1616:  MOVLW  86
1618:  MOVWF  x49
161A:  MOVLB  0
161C:  CALL   0198
1620:  BTFSC  16.7
1622:  BSF    FF2.7
1624:  CLRF   16
1626:  BTFSC  FF2.7
1628:  BSF    16.7
162A:  BCF    FF2.7
162C:  MOVLB  1
162E:  CLRF   x48
1630:  CLRF   x47
1632:  MOVLW  48
1634:  MOVWF  x46
1636:  MOVLW  85
1638:  MOVWF  x45
163A:  MOVFF  03,14C
163E:  MOVFF  02,14B
1642:  MOVFF  01,14A
1646:  MOVFF  00,149
164A:  MOVLB  0
164C:  CALL   0198
1650:  BTFSC  16.7
1652:  BSF    FF2.7
1654:  MOVFF  00,D1
1658:  MOVFF  01,D2
165C:  MOVFF  02,D3
1660:  MOVFF  03,D4
1664:  CLRF   16
1666:  BTFSC  FF2.7
1668:  BSF    16.7
166A:  BCF    FF2.7
166C:  MOVFF  03,14C
1670:  MOVFF  02,14B
1674:  MOVFF  01,14A
1678:  MOVFF  00,149
167C:  MOVLB  1
167E:  CLRF   x50
1680:  MOVLW  80
1682:  MOVWF  x4F
1684:  MOVLW  2C
1686:  MOVWF  x4E
1688:  MOVLW  87
168A:  MOVWF  x4D
168C:  MOVLB  0
168E:  CALL   02C4
1692:  BTFSC  16.7
1694:  BSF    FF2.7
1696:  CLRF   16
1698:  BTFSC  FF2.7
169A:  BSF    16.7
169C:  BCF    FF2.7
169E:  MOVFF  03,146
16A2:  MOVFF  02,145
16A6:  MOVFF  01,144
16AA:  MOVFF  00,143
16AE:  CALL   08EA
16B2:  BTFSC  16.7
16B4:  BSF    FF2.7
16B6:  MOVFF  03,47
16BA:  MOVFF  02,46
16BE:  MOVFF  01,45
16C2:  MOVFF  00,44
....................         break;          
16C6:  BRA    16CA
....................       
....................       } 
....................        default:  break; 
16C8:  BRA    16CA
....................       } 
....................       }  
....................       } 
16CA:  GOTO   28FC (RETURN)
.................... void pid_robot() 
.................... { 
....................   pid_right(); 
*
2400:  GOTO   1760
....................   pid_left(); 
2404:  GOTO   19E8
....................   if ((!copid_right)&&(!copid_left)&&(!donePID)) 
2408:  BTFSC  3B.2
240A:  BRA    272C
240C:  BTFSC  3B.3
240E:  BRA    272C
2410:  BTFSC  3B.5
2412:  BRA    272C
....................   { 
....................   if (huong=='R') 
2414:  MOVF   3A,W
2416:  SUBLW  52
2418:  BNZ   2460
....................   { 
....................         angle_current  -= value_cmd; 
241A:  BSF    FD8.1
241C:  CLRF   16
241E:  BTFSC  FF2.7
2420:  BSF    16.7
2422:  BCF    FF2.7
2424:  MOVFF  5F,14C
2428:  MOVFF  5E,14B
242C:  MOVFF  5D,14A
2430:  MOVFF  5C,149
2434:  MOVFF  57,150
2438:  MOVFF  56,14F
243C:  MOVFF  55,14E
2440:  MOVFF  54,14D
2444:  CALL   0422
2448:  BTFSC  16.7
244A:  BSF    FF2.7
244C:  MOVFF  03,5F
2450:  MOVFF  02,5E
2454:  MOVFF  01,5D
2458:  MOVFF  00,5C
....................         huong = ""; 
245C:  CLRF   3A
....................   } 
....................   else if (huong=='L') 
245E:  BRA    24F2
2460:  MOVF   3A,W
2462:  SUBLW  4C
2464:  BNZ   24AC
....................   { 
....................      angle_current  += value_cmd; 
2466:  BCF    FD8.1
2468:  CLRF   16
246A:  BTFSC  FF2.7
246C:  BSF    16.7
246E:  BCF    FF2.7
2470:  MOVFF  5F,14C
2474:  MOVFF  5E,14B
2478:  MOVFF  5D,14A
247C:  MOVFF  5C,149
2480:  MOVFF  57,150
2484:  MOVFF  56,14F
2488:  MOVFF  55,14E
248C:  MOVFF  54,14D
2490:  CALL   0422
2494:  BTFSC  16.7
2496:  BSF    FF2.7
2498:  MOVFF  03,5F
249C:  MOVFF  02,5E
24A0:  MOVFF  01,5D
24A4:  MOVFF  00,5C
....................       huong = ""; 
24A8:  CLRF   3A
....................   } 
....................   else if (huong=='T') 
24AA:  BRA    24F2
24AC:  MOVF   3A,W
24AE:  SUBLW  54
24B0:  BNZ   24C8
....................   { 
....................         xy_vitri(value_cmd); 
24B2:  MOVFF  57,D3
24B6:  MOVFF  56,D2
24BA:  MOVFF  55,D1
24BE:  MOVFF  54,D0
24C2:  RCALL  217A
....................          huong = ""; 
24C4:  CLRF   3A
....................   } 
....................   else if (huong=='B') 
24C6:  BRA    24F2
24C8:  MOVF   3A,W
24CA:  SUBLW  42
24CC:  BNZ   24F2
....................   { 
....................        xy_vitri(-value_cmd); 
24CE:  MOVFF  54,CC
24D2:  MOVF   55,W
24D4:  XORLW  80
24D6:  MOVWF  xCD
24D8:  MOVFF  56,CE
24DC:  MOVFF  57,CF
24E0:  MOVFF  57,D3
24E4:  MOVFF  56,D2
24E8:  MOVWF  xD1
24EA:  MOVFF  54,D0
24EE:  RCALL  217A
....................          huong = ""; 
24F0:  CLRF   3A
....................   } 
....................    if (angle_current >= 360.0) angle_current -= 360.0; 
24F2:  MOVLB  1
24F4:  CLRF   x11
24F6:  CLRF   x10
24F8:  MOVLW  34
24FA:  MOVWF  x0F
24FC:  MOVLW  87
24FE:  MOVWF  x0E
2500:  MOVFF  5F,115
2504:  MOVFF  5E,114
2508:  MOVFF  5D,113
250C:  MOVFF  5C,112
2510:  MOVLB  0
2512:  CALL   1C70
2516:  BC    251A
2518:  BNZ   255C
251A:  BSF    FD8.1
251C:  CLRF   16
251E:  BTFSC  FF2.7
2520:  BSF    16.7
2522:  BCF    FF2.7
2524:  MOVFF  5F,14C
2528:  MOVFF  5E,14B
252C:  MOVFF  5D,14A
2530:  MOVFF  5C,149
2534:  MOVLB  1
2536:  CLRF   x50
2538:  CLRF   x4F
253A:  MOVLW  34
253C:  MOVWF  x4E
253E:  MOVLW  87
2540:  MOVWF  x4D
2542:  MOVLB  0
2544:  CALL   0422
2548:  BTFSC  16.7
254A:  BSF    FF2.7
254C:  MOVFF  03,5F
2550:  MOVFF  02,5E
2554:  MOVFF  01,5D
2558:  MOVFF  00,5C
....................     if (angle_current < 0 ) angle_current += 360.0; 
255C:  MOVFF  5F,111
2560:  MOVFF  5E,110
2564:  MOVFF  5D,10F
2568:  MOVFF  5C,10E
256C:  MOVLB  1
256E:  CLRF   x15
2570:  CLRF   x14
2572:  CLRF   x13
2574:  CLRF   x12
2576:  MOVLB  0
2578:  CALL   1C70
257C:  BNC   25C0
257E:  BCF    FD8.1
2580:  CLRF   16
2582:  BTFSC  FF2.7
2584:  BSF    16.7
2586:  BCF    FF2.7
2588:  MOVFF  5F,14C
258C:  MOVFF  5E,14B
2590:  MOVFF  5D,14A
2594:  MOVFF  5C,149
2598:  MOVLB  1
259A:  CLRF   x50
259C:  CLRF   x4F
259E:  MOVLW  34
25A0:  MOVWF  x4E
25A2:  MOVLW  87
25A4:  MOVWF  x4D
25A6:  MOVLB  0
25A8:  CALL   0422
25AC:  BTFSC  16.7
25AE:  BSF    FF2.7
25B0:  MOVFF  03,5F
25B4:  MOVFF  02,5E
25B8:  MOVFF  01,5D
25BC:  MOVFF  00,5C
25C0:  CLRF   16
25C2:  BTFSC  FF2.7
25C4:  BSF    16.7
25C6:  BCF    FF2.7
....................     x_cur=(int32) x_cur; 
25C8:  MOVFF  2D,146
25CC:  MOVFF  2C,145
25D0:  MOVFF  2B,144
25D4:  MOVFF  2A,143
25D8:  CALL   08EA
25DC:  BTFSC  16.7
25DE:  BSF    FF2.7
25E0:  MOVFF  03,CF
25E4:  MOVFF  02,CE
25E8:  MOVFF  01,CD
25EC:  MOVFF  00,CC
25F0:  RCALL  23CC
25F2:  MOVFF  03,2D
25F6:  MOVFF  02,2C
25FA:  MOVFF  01,2B
25FE:  MOVFF  00,2A
2602:  CLRF   16
2604:  BTFSC  FF2.7
2606:  BSF    16.7
2608:  BCF    FF2.7
....................     y_cur=(int32) y_cur; 
260A:  MOVFF  31,146
260E:  MOVFF  30,145
2612:  MOVFF  2F,144
2616:  MOVFF  2E,143
261A:  CALL   08EA
261E:  BTFSC  16.7
2620:  BSF    FF2.7
2622:  MOVFF  03,CF
2626:  MOVFF  02,CE
262A:  MOVFF  01,CD
262E:  MOVFF  00,CC
2632:  RCALL  23CC
2634:  MOVFF  03,31
2638:  MOVFF  02,30
263C:  MOVFF  01,2F
2640:  MOVFF  00,2E
2644:  CLRF   16
2646:  BTFSC  FF2.7
2648:  BSF    16.7
264A:  BCF    FF2.7
....................     angle_current= (int32) angle_current; 
264C:  MOVFF  5F,146
2650:  MOVFF  5E,145
2654:  MOVFF  5D,144
2658:  MOVFF  5C,143
265C:  CALL   08EA
2660:  BTFSC  16.7
2662:  BSF    FF2.7
2664:  MOVFF  03,CF
2668:  MOVFF  02,CE
266C:  MOVFF  01,CD
2670:  MOVFF  00,CC
2674:  RCALL  23CC
2676:  MOVFF  03,5F
267A:  MOVFF  02,5E
267E:  MOVFF  01,5D
2682:  MOVFF  00,5C
....................           
....................    printf("X%fY%fZ%fA", x_cur, y_cur, angle_current); 
2686:  MOVLW  58
2688:  BTFSS  F9E.4
268A:  BRA    2688
268C:  MOVWF  FAD
268E:  MOVLW  89
2690:  MOVWF  FE9
2692:  CLRF   16
2694:  BTFSC  FF2.7
2696:  BSF    16.7
2698:  BCF    FF2.7
269A:  MOVFF  2D,139
269E:  MOVFF  2C,138
26A2:  MOVFF  2B,137
26A6:  MOVFF  2A,136
26AA:  MOVLW  02
26AC:  MOVLB  1
26AE:  MOVWF  x3A
26B0:  MOVLB  0
26B2:  CALL   09AC
26B6:  BTFSC  16.7
26B8:  BSF    FF2.7
26BA:  MOVLW  59
26BC:  BTFSS  F9E.4
26BE:  BRA    26BC
26C0:  MOVWF  FAD
26C2:  MOVLW  89
26C4:  MOVWF  FE9
26C6:  CLRF   16
26C8:  BTFSC  FF2.7
26CA:  BSF    16.7
26CC:  BCF    FF2.7
26CE:  MOVFF  31,139
26D2:  MOVFF  30,138
26D6:  MOVFF  2F,137
26DA:  MOVFF  2E,136
26DE:  MOVLW  02
26E0:  MOVLB  1
26E2:  MOVWF  x3A
26E4:  MOVLB  0
26E6:  CALL   09AC
26EA:  BTFSC  16.7
26EC:  BSF    FF2.7
26EE:  MOVLW  5A
26F0:  BTFSS  F9E.4
26F2:  BRA    26F0
26F4:  MOVWF  FAD
26F6:  MOVLW  89
26F8:  MOVWF  FE9
26FA:  CLRF   16
26FC:  BTFSC  FF2.7
26FE:  BSF    16.7
2700:  BCF    FF2.7
2702:  MOVFF  5F,139
2706:  MOVFF  5E,138
270A:  MOVFF  5D,137
270E:  MOVFF  5C,136
2712:  MOVLW  02
2714:  MOVLB  1
2716:  MOVWF  x3A
2718:  MOVLB  0
271A:  CALL   09AC
271E:  BTFSC  16.7
2720:  BSF    FF2.7
2722:  MOVLW  41
2724:  BTFSS  F9E.4
2726:  BRA    2724
2728:  MOVWF  FAD
....................     donePID = 1;    
272A:  BSF    3B.5
....................    
....................   } 
....................    
.................... } 
272C:  GOTO   28FE (RETURN)
.................... void xy_vitri(float khoangcach) 
.................... { 
*
217A:  CLRF   16
217C:  BTFSC  FF2.7
217E:  BSF    16.7
2180:  BCF    FF2.7
....................  x_cur = x_cur_old + khoangcach*cos(angle_current*PI/180.0); 
2182:  MOVFF  5F,148
2186:  MOVFF  5E,147
218A:  MOVFF  5D,146
218E:  MOVFF  5C,145
2192:  MOVLW  DB
2194:  MOVLB  1
2196:  MOVWF  x4C
2198:  MOVLW  0F
219A:  MOVWF  x4B
219C:  MOVLW  49
219E:  MOVWF  x4A
21A0:  MOVLW  80
21A2:  MOVWF  x49
21A4:  MOVLB  0
21A6:  CALL   0198
21AA:  BTFSC  16.7
21AC:  BSF    FF2.7
21AE:  MOVFF  00,D4
21B2:  MOVFF  01,D5
21B6:  MOVFF  02,D6
21BA:  MOVFF  03,D7
21BE:  CLRF   16
21C0:  BTFSC  FF2.7
21C2:  BSF    16.7
21C4:  BCF    FF2.7
21C6:  MOVFF  03,14C
21CA:  MOVFF  02,14B
21CE:  MOVFF  01,14A
21D2:  MOVFF  00,149
21D6:  MOVLB  1
21D8:  CLRF   x50
21DA:  CLRF   x4F
21DC:  MOVLW  34
21DE:  MOVWF  x4E
21E0:  MOVLW  86
21E2:  MOVWF  x4D
21E4:  MOVLB  0
21E6:  CALL   02C4
21EA:  BTFSC  16.7
21EC:  BSF    FF2.7
21EE:  MOVFF  00,D4
21F2:  MOVFF  01,D5
21F6:  MOVFF  02,D6
21FA:  MOVFF  03,D7
21FE:  MOVFF  03,E3
2202:  MOVFF  02,E2
2206:  MOVFF  01,E1
220A:  MOVFF  00,E0
220E:  RCALL  1CEA
2210:  CLRF   16
2212:  BTFSC  FF2.7
2214:  BSF    16.7
2216:  BCF    FF2.7
2218:  MOVFF  D3,148
221C:  MOVFF  D2,147
2220:  MOVFF  D1,146
2224:  MOVFF  D0,145
2228:  MOVFF  03,14C
222C:  MOVFF  02,14B
2230:  MOVFF  01,14A
2234:  MOVFF  00,149
2238:  CALL   0198
223C:  BTFSC  16.7
223E:  BSF    FF2.7
2240:  MOVFF  FEA,D5
2244:  MOVFF  FE9,D4
2248:  BCF    FD8.1
224A:  CLRF   16
224C:  BTFSC  FF2.7
224E:  BSF    16.7
2250:  BCF    FF2.7
2252:  MOVFF  35,14C
2256:  MOVFF  34,14B
225A:  MOVFF  33,14A
225E:  MOVFF  32,149
2262:  MOVFF  03,150
2266:  MOVFF  02,14F
226A:  MOVFF  01,14E
226E:  MOVFF  00,14D
2272:  CALL   0422
2276:  BTFSC  16.7
2278:  BSF    FF2.7
227A:  MOVFF  D5,FEA
227E:  MOVFF  D4,FE9
2282:  MOVFF  03,2D
2286:  MOVFF  02,2C
228A:  MOVFF  01,2B
228E:  MOVFF  00,2A
2292:  CLRF   16
2294:  BTFSC  FF2.7
2296:  BSF    16.7
2298:  BCF    FF2.7
....................  y_cur = y_cur_old + khoangcach*sin(angle_current*PI/180.0); 
229A:  MOVFF  5F,148
229E:  MOVFF  5E,147
22A2:  MOVFF  5D,146
22A6:  MOVFF  5C,145
22AA:  MOVLW  DB
22AC:  MOVLB  1
22AE:  MOVWF  x4C
22B0:  MOVLW  0F
22B2:  MOVWF  x4B
22B4:  MOVLW  49
22B6:  MOVWF  x4A
22B8:  MOVLW  80
22BA:  MOVWF  x49
22BC:  MOVLB  0
22BE:  CALL   0198
22C2:  BTFSC  16.7
22C4:  BSF    FF2.7
22C6:  MOVFF  00,D4
22CA:  MOVFF  01,D5
22CE:  MOVFF  02,D6
22D2:  MOVFF  03,D7
22D6:  CLRF   16
22D8:  BTFSC  FF2.7
22DA:  BSF    16.7
22DC:  BCF    FF2.7
22DE:  MOVFF  03,14C
22E2:  MOVFF  02,14B
22E6:  MOVFF  01,14A
22EA:  MOVFF  00,149
22EE:  MOVLB  1
22F0:  CLRF   x50
22F2:  CLRF   x4F
22F4:  MOVLW  34
22F6:  MOVWF  x4E
22F8:  MOVLW  86
22FA:  MOVWF  x4D
22FC:  MOVLB  0
22FE:  CALL   02C4
2302:  BTFSC  16.7
2304:  BSF    FF2.7
2306:  MOVFF  00,D4
230A:  MOVFF  01,D5
230E:  MOVFF  02,D6
2312:  MOVFF  03,D7
2316:  MOVFF  03,DB
231A:  MOVFF  02,DA
231E:  MOVFF  01,D9
2322:  MOVFF  00,D8
2326:  BRA    211E
2328:  CLRF   16
232A:  BTFSC  FF2.7
232C:  BSF    16.7
232E:  BCF    FF2.7
2330:  MOVFF  D3,148
2334:  MOVFF  D2,147
2338:  MOVFF  D1,146
233C:  MOVFF  D0,145
2340:  MOVFF  03,14C
2344:  MOVFF  02,14B
2348:  MOVFF  01,14A
234C:  MOVFF  00,149
2350:  CALL   0198
2354:  BTFSC  16.7
2356:  BSF    FF2.7
2358:  MOVFF  FEA,D5
235C:  MOVFF  FE9,D4
2360:  BCF    FD8.1
2362:  CLRF   16
2364:  BTFSC  FF2.7
2366:  BSF    16.7
2368:  BCF    FF2.7
236A:  MOVFF  39,14C
236E:  MOVFF  38,14B
2372:  MOVFF  37,14A
2376:  MOVFF  36,149
237A:  MOVFF  03,150
237E:  MOVFF  02,14F
2382:  MOVFF  01,14E
2386:  MOVFF  00,14D
238A:  CALL   0422
238E:  BTFSC  16.7
2390:  BSF    FF2.7
2392:  MOVFF  D5,FEA
2396:  MOVFF  D4,FE9
239A:  MOVFF  03,31
239E:  MOVFF  02,30
23A2:  MOVFF  01,2F
23A6:  MOVFF  00,2E
....................  x_cur_old = x_cur; 
23AA:  MOVFF  2D,35
23AE:  MOVFF  2C,34
23B2:  MOVFF  2B,33
23B6:  MOVFF  2A,32
....................  y_cur_old = y_cur;  
23BA:  MOVFF  31,39
23BE:  MOVFF  30,38
23C2:  MOVFF  2F,37
23C6:  MOVFF  2E,36
.................... } 
23CA:  RETLW  00
....................  

Configuration Fuses:
   Word  1: CC24   IESO FCMEN HS PLL5 CPUDIV1 USBDIV
   Word  2: 1E39   NOBROWNOUT NOWDT BORV20 NOPUT WDT32768 VREGEN
   Word  3: 8700   PBADEN CCP2C1 MCLR LPT1OSC
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST NOICPRT
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
