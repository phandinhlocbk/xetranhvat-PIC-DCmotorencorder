CCS PCH C Compiler, Version 4.104, 5967               25-Oct-15 20:17

               Filename: C:\Users\ken\Desktop\CCS\basic.lst

               ROM used: 10664 bytes (33%)
                         Largest free fragment is 22100
               RAM used: 210 (10%) at main() level
                         350 (17%) worst case
               Stack:    8 worst case (5 in main + 3 for interrupts)

*
0000:  GOTO   27EA
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  F9D.0
004A:  GOTO   0054
004E:  BTFSC  F9E.0
0050:  GOTO   0A64
0054:  BTFSS  FF0.3
0056:  GOTO   0060
005A:  BTFSC  FF0.0
005C:  GOTO   09AC
0060:  BTFSS  FF0.4
0062:  GOTO   006C
0066:  BTFSC  FF0.1
0068:  GOTO   0A24
006C:  BTFSS  F9D.5
006E:  GOTO   0078
0072:  BTFSC  F9E.5
0074:  GOTO   08E0
0078:  MOVFF  0E,00
007C:  MOVFF  0F,01
0080:  MOVFF  10,02
0084:  MOVFF  11,03
0088:  MOVFF  0C,FE9
008C:  MOVFF  07,FEA
0090:  BSF    07.7
0092:  MOVFF  08,FE1
0096:  MOVFF  09,FE2
009A:  MOVFF  0A,FD9
009E:  MOVFF  0B,FDA
00A2:  MOVFF  12,FF3
00A6:  MOVFF  13,FF4
00AA:  MOVFF  14,FFA
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #include <STDDEF.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... //////////// 
.................... #DEVICE ADC=10 
.................... #FUSES NOWDT  
.................... #FUSES HSPLL       
.................... #FUSES MCLR       
.................... #FUSES NOPROTECT        
.................... #FUSES NOLVP        
.................... #FUSES NODEBUG        
.................... #FUSES USBDIV        
.................... #FUSES PLL5        
.................... #FUSES CPUDIV1        
.................... #FUSES VREGEN   
.................... #FUSES HS, NOPUT, NOBROWNOUT, NOCPD, NOWRT 
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
*
010E:  MOVFF  13D,142
0112:  MOVFF  13C,141
0116:  MOVLB  1
0118:  MOVF   x40,F
011A:  BZ    0164
011C:  MOVFF  13F,03
0120:  MOVFF  13E,FE9
0124:  MOVFF  13F,FEA
0128:  MOVF   FEF,F
012A:  BZ    0164
....................      *s++ = *s2++; 
012C:  MOVFF  142,03
0130:  MOVF   x41,W
0132:  INCF   x41,F
0134:  BTFSC  FD8.2
0136:  INCF   x42,F
0138:  MOVWF  x43
013A:  MOVFF  03,144
013E:  MOVFF  13F,03
0142:  MOVF   x3E,W
0144:  INCF   x3E,F
0146:  BTFSC  FD8.2
0148:  INCF   x3F,F
014A:  MOVWF  FE9
014C:  MOVFF  03,FEA
0150:  MOVFF  FEF,145
0154:  MOVFF  144,FEA
0158:  MOVFF  143,FE9
015C:  MOVFF  145,FEF
0160:  DECF   x40,F
0162:  BRA    0118
....................   for (; n > 0; n--) 
0164:  MOVF   x40,F
0166:  BZ    0180
....................      *s++ = '\0'; 
0168:  MOVFF  142,03
016C:  MOVF   x41,W
016E:  INCF   x41,F
0170:  BTFSC  FD8.2
0172:  INCF   x42,F
0174:  MOVWF  FE9
0176:  MOVFF  03,FEA
017A:  CLRF   FEF
017C:  DECF   x40,F
017E:  BRA    0164
....................  
....................   return(s1); 
0180:  MOVFF  13C,01
0184:  MOVFF  13D,02
.................... } 
0188:  MOVLB  0
018A:  GOTO   094C (RETURN)
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
00D2:  MOVFF  13C,13E
00D6:  MOVFF  13B,13D
00DA:  MOVFF  13E,03
00DE:  MOVLB  1
00E0:  MOVFF  13D,FE9
00E4:  MOVFF  13E,FEA
00E8:  MOVF   FEF,F
00EA:  BZ    00F8
00EC:  INCF   x3D,F
00EE:  BTFSC  FD8.2
00F0:  INCF   x3E,F
00F2:  MOVLB  0
00F4:  BRA    00DA
00F6:  MOVLB  1
....................    return(sc - s); 
00F8:  MOVF   x3B,W
00FA:  SUBWF  x3D,W
00FC:  MOVWF  00
00FE:  MOVF   x3C,W
0100:  SUBWFB x3E,W
0102:  MOVWF  03
0104:  MOVFF  00,01
.................... } 
0108:  MOVLB  0
010A:  GOTO   092C (RETURN)
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
*
0690:  MOVLB  1
0692:  CLRF   x42
0694:  CLRF   x41
0696:  CLRF   x40
0698:  MOVLW  7F
069A:  MOVWF  x3F
069C:  CLRF   x46
069E:  CLRF   x45
06A0:  CLRF   x44
06A2:  CLRF   x43
06A4:  BSF    x47.0
06A6:  BCF    x47.1
06A8:  BCF    x47.2
06AA:  CLRF   x49
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
06AC:  MOVF   x3B,W
06AE:  IORWF  x3C,W
06B0:  BNZ   06BC
....................       return 0; 
06B2:  CLRF   00
06B4:  CLRF   01
06B6:  CLRF   02
06B8:  CLRF   03
06BA:  BRA    08DA
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
06BC:  MOVF   x49,W
06BE:  INCF   x49,F
06C0:  CLRF   03
06C2:  ADDWF  x3B,W
06C4:  MOVWF  FE9
06C6:  MOVF   x3C,W
06C8:  ADDWFC 03,W
06CA:  MOVWF  FEA
06CC:  MOVFF  FEF,148
06D0:  MOVF   x48,F
06D2:  BTFSC  FD8.2
06D4:  BRA    0860
....................    { 
....................       if (skip && !isspace(c)) 
06D6:  BTFSS  x47.0
06D8:  BRA    06F8
06DA:  MOVF   x48,W
06DC:  SUBLW  20
06DE:  BZ    06F8
....................       { 
....................          skip = 0; 
06E0:  BCF    x47.0
....................          if (c == '+') 
06E2:  MOVF   x48,W
06E4:  SUBLW  2B
06E6:  BNZ   06EE
....................          { 
....................             sign = 0; 
06E8:  BCF    x47.1
....................             continue; 
06EA:  BRA    0846
....................          }             
....................          else if (c == '-') 
06EC:  BRA    06F8
06EE:  MOVF   x48,W
06F0:  SUBLW  2D
06F2:  BNZ   06F8
....................          { 
....................             sign = 1; 
06F4:  BSF    x47.1
....................             continue; 
06F6:  BRA    0846
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
06F8:  BTFSC  x47.0
06FA:  BRA    070A
06FC:  MOVF   x48,W
06FE:  SUBLW  2E
0700:  BNZ   070A
0702:  BTFSC  x47.2
0704:  BRA    070A
....................          point = 1; 
0706:  BSF    x47.2
....................       else if (!skip && isdigit(c)) 
0708:  BRA    0846
070A:  BTFSC  x47.0
070C:  BRA    0840
070E:  MOVF   x48,W
0710:  SUBLW  2F
0712:  BTFSC  FD8.0
0714:  BRA    0840
0716:  MOVF   x48,W
0718:  SUBLW  39
071A:  BTFSS  FD8.0
071C:  BRA    0840
....................       { 
....................          c -= '0'; 
071E:  MOVLW  30
0720:  SUBWF  x48,F
....................          if (point) 
0722:  BTFSS  x47.2
0724:  BRA    07CC
....................          { 
....................             pow10 = pow10 * 10.0; 
0726:  MOVFF  142,14D
072A:  MOVFF  141,14C
072E:  MOVFF  140,14B
0732:  MOVFF  13F,14A
0736:  CLRF   x51
0738:  CLRF   x50
073A:  MOVLW  20
073C:  MOVWF  x4F
073E:  MOVLW  82
0740:  MOVWF  x4E
0742:  MOVLB  0
0744:  RCALL  018E
0746:  MOVFF  03,142
074A:  MOVFF  02,141
074E:  MOVFF  01,140
0752:  MOVFF  00,13F
....................             result += (float)c / pow10;    
0756:  MOVLB  1
0758:  CLRF   x4F
075A:  MOVFF  148,14E
075E:  MOVLB  0
0760:  RCALL  0284
0762:  MOVFF  00,14A
0766:  MOVFF  01,14B
076A:  MOVFF  02,14C
076E:  MOVFF  03,14D
0772:  MOVFF  03,151
0776:  MOVFF  02,150
077A:  MOVFF  01,14F
077E:  MOVFF  00,14E
0782:  MOVFF  142,155
0786:  MOVFF  141,154
078A:  MOVFF  140,153
078E:  MOVFF  13F,152
0792:  RCALL  02BA
0794:  BCF    FD8.1
0796:  MOVFF  146,151
079A:  MOVFF  145,150
079E:  MOVFF  144,14F
07A2:  MOVFF  143,14E
07A6:  MOVFF  03,155
07AA:  MOVFF  02,154
07AE:  MOVFF  01,153
07B2:  MOVFF  00,152
07B6:  RCALL  0418
07B8:  MOVFF  03,146
07BC:  MOVFF  02,145
07C0:  MOVFF  01,144
07C4:  MOVFF  00,143
....................          } 
....................          else 
07C8:  BRA    083C
07CA:  MOVLB  1
....................          { 
....................             result = 10.0 * result + (float)c; 
07CC:  CLRF   x4D
07CE:  CLRF   x4C
07D0:  MOVLW  20
07D2:  MOVWF  x4B
07D4:  MOVLW  82
07D6:  MOVWF  x4A
07D8:  MOVFF  146,151
07DC:  MOVFF  145,150
07E0:  MOVFF  144,14F
07E4:  MOVFF  143,14E
07E8:  MOVLB  0
07EA:  RCALL  018E
07EC:  MOVFF  00,14A
07F0:  MOVFF  01,14B
07F4:  MOVFF  02,14C
07F8:  MOVFF  03,14D
07FC:  MOVLB  1
07FE:  CLRF   x4F
0800:  MOVFF  148,14E
0804:  MOVLB  0
0806:  RCALL  0284
0808:  BCF    FD8.1
080A:  MOVFF  14D,151
080E:  MOVFF  14C,150
0812:  MOVFF  14B,14F
0816:  MOVFF  14A,14E
081A:  MOVFF  03,155
081E:  MOVFF  02,154
0822:  MOVFF  01,153
0826:  MOVFF  00,152
082A:  RCALL  0418
082C:  MOVFF  03,146
0830:  MOVFF  02,145
0834:  MOVFF  01,144
0838:  MOVFF  00,143
....................          } 
....................       } 
....................       else if (!skip) 
083C:  BRA    0848
083E:  MOVLB  1
0840:  BTFSC  x47.0
0842:  BRA    0846
....................          break; 
0844:  BRA    0860
0846:  MOVLB  0
....................    } 
0848:  MOVLB  1
084A:  MOVF   x49,W
084C:  INCF   x49,F
084E:  CLRF   03
0850:  ADDWF  x3B,W
0852:  MOVWF  FE9
0854:  MOVF   x3C,W
0856:  ADDWFC 03,W
0858:  MOVWF  FEA
085A:  MOVFF  FEF,148
085E:  BRA    06D0
....................  
....................    if (sign) 
0860:  BTFSS  x47.1
0862:  BRA    0896
....................       result = -1*result; 
0864:  CLRF   x4D
0866:  CLRF   x4C
0868:  MOVLW  80
086A:  MOVWF  x4B
086C:  MOVLW  7F
086E:  MOVWF  x4A
0870:  MOVFF  146,151
0874:  MOVFF  145,150
0878:  MOVFF  144,14F
087C:  MOVFF  143,14E
0880:  MOVLB  0
0882:  RCALL  018E
0884:  MOVFF  03,146
0888:  MOVFF  02,145
088C:  MOVFF  01,144
0890:  MOVFF  00,143
0894:  MOVLB  1
....................        
....................    if(endptr) 
0896:  MOVF   x3D,W
0898:  IORWF  x3E,W
089A:  BZ    08CA
....................    { 
....................       if (ptr) { 
089C:  MOVF   x49,F
089E:  BZ    08B8
....................          ptr--; 
08A0:  DECF   x49,F
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
08A2:  MOVFF  13D,FE9
08A6:  MOVFF  13E,FEA
08AA:  MOVF   x49,W
08AC:  ADDWF  x3B,W
08AE:  MOVWF  FEF
08B0:  MOVLW  00
08B2:  ADDWFC x3C,W
08B4:  MOVWF  FEC
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
08B6:  BRA    08CA
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
08B8:  MOVFF  13D,FE9
08BC:  MOVFF  13E,FEA
08C0:  MOVFF  13C,FEC
08C4:  MOVF   FED,F
08C6:  MOVFF  13B,FEF
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
08CA:  MOVFF  143,00
08CE:  MOVFF  144,01
08D2:  MOVFF  145,02
08D6:  MOVFF  146,03
.................... } 
08DA:  MOVLB  0
08DC:  GOTO   095E (RETURN)
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float32)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float32)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float48)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float48)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float64)l); 
....................   res = 32768.0*(float64)l; 
....................   res += (float64)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y/LN2 - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y/LN2 - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y/LN2 - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................    bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float32 const pl_64[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql_64[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
.................... #endif 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................       bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................    bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................      bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI          0.6366197723675813 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
*
1B7C:  CLRF   xF4
1B7E:  CLRF   xF3
1B80:  CLRF   xF2
1B82:  MOVLW  7F
1B84:  MOVWF  xF1
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
1B86:  MOVLW  7E
1B88:  MOVWF  xFB
1B8A:  MOVLW  80
1B8C:  MOVWF  xFC
1B8E:  CLRF   xFD
1B90:  CLRF   xFE
1B92:  MOVLW  7A
1B94:  MOVWF  xFF
1B96:  MOVLW  2A
1B98:  MOVLB  1
1B9A:  MOVWF  x00
1B9C:  MOVLW  AA
1B9E:  MOVWF  x01
1BA0:  MOVLW  AB
1BA2:  MOVWF  x02
1BA4:  MOVLW  75
1BA6:  MOVWF  x03
1BA8:  MOVLW  B6
1BAA:  MOVWF  x04
1BAC:  MOVLW  0B
1BAE:  MOVWF  x05
1BB0:  MOVLW  61
1BB2:  MOVWF  x06
1BB4:  MOVLW  6F
1BB6:  MOVWF  x07
1BB8:  MOVLW  50
1BBA:  MOVWF  x08
1BBC:  MOVLW  0D
1BBE:  MOVWF  x09
1BC0:  MOVLW  01
1BC2:  MOVWF  x0A
1BC4:  MOVLW  69
1BC6:  MOVWF  x0B
1BC8:  MOVLW  93
1BCA:  MOVWF  x0C
1BCC:  MOVLW  F2
1BCE:  MOVWF  x0D
1BD0:  MOVLW  7E
1BD2:  MOVWF  x0E
1BD4:  MOVLW  62
1BD6:  MOVWF  x0F
1BD8:  MOVLW  0F
1BDA:  MOVWF  x10
1BDC:  MOVLW  76
1BDE:  MOVWF  x11
1BE0:  MOVLW  AE
1BE2:  MOVWF  x12
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
1BE4:  MOVFF  E8,116
1BE8:  MOVFF  E7,115
1BEC:  MOVFF  E6,114
1BF0:  MOVFF  E5,113
1BF4:  CLRF   x1A
1BF6:  CLRF   x19
1BF8:  CLRF   x18
1BFA:  CLRF   x17
1BFC:  MOVLB  0
1BFE:  RCALL  1B02
1C00:  BNC   1C08
1C02:  MOVF   xE6,W
1C04:  XORLW  80
1C06:  MOVWF  xE6
1C08:  CLRF   16
1C0A:  BTFSC  FF2.7
1C0C:  BSF    16.7
1C0E:  BCF    FF2.7
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
1C10:  MOVFF  E8,151
1C14:  MOVFF  E7,150
1C18:  MOVFF  E6,14F
1C1C:  MOVFF  E5,14E
1C20:  MOVLW  DB
1C22:  MOVLB  1
1C24:  MOVWF  x55
1C26:  MOVLW  0F
1C28:  MOVWF  x54
1C2A:  MOVLW  49
1C2C:  MOVWF  x53
1C2E:  MOVLW  7F
1C30:  MOVWF  x52
1C32:  MOVLB  0
1C34:  CALL   02BA
1C38:  BTFSC  16.7
1C3A:  BSF    FF2.7
1C3C:  MOVFF  03,116
1C40:  MOVFF  02,115
1C44:  MOVFF  01,114
1C48:  MOVFF  00,113
1C4C:  RCALL  14B8
1C4E:  MOVFF  01,F5
1C52:  CLRF   16
1C54:  BTFSC  FF2.7
1C56:  BSF    16.7
1C58:  BCF    FF2.7
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
1C5A:  MOVFF  E8,151
1C5E:  MOVFF  E7,150
1C62:  MOVFF  E6,14F
1C66:  MOVFF  E5,14E
1C6A:  MOVLW  DB
1C6C:  MOVLB  1
1C6E:  MOVWF  x55
1C70:  MOVLW  0F
1C72:  MOVWF  x54
1C74:  MOVLW  49
1C76:  MOVWF  x53
1C78:  MOVLW  7F
1C7A:  MOVWF  x52
1C7C:  MOVLB  0
1C7E:  CALL   02BA
1C82:  BTFSC  16.7
1C84:  BSF    FF2.7
1C86:  MOVFF  00,113
1C8A:  MOVFF  01,114
1C8E:  MOVFF  02,115
1C92:  MOVFF  03,116
1C96:  CLRF   16
1C98:  BTFSC  FF2.7
1C9A:  BSF    16.7
1C9C:  BCF    FF2.7
1C9E:  MOVLB  1
1CA0:  CLRF   x4F
1CA2:  MOVFF  F5,14E
1CA6:  MOVLB  0
1CA8:  CALL   0284
1CAC:  BTFSC  16.7
1CAE:  BSF    FF2.7
1CB0:  BSF    FD8.1
1CB2:  CLRF   16
1CB4:  BTFSC  FF2.7
1CB6:  BSF    16.7
1CB8:  BCF    FF2.7
1CBA:  MOVFF  116,151
1CBE:  MOVFF  115,150
1CC2:  MOVFF  114,14F
1CC6:  MOVFF  113,14E
1CCA:  MOVFF  03,155
1CCE:  MOVFF  02,154
1CD2:  MOVFF  01,153
1CD6:  MOVFF  00,152
1CDA:  CALL   0418
1CDE:  BTFSC  16.7
1CE0:  BSF    FF2.7
1CE2:  MOVFF  03,FA
1CE6:  MOVFF  02,F9
1CEA:  MOVFF  01,F8
1CEE:  MOVFF  00,F7
....................    quad = quad % 4;                    // quadrant (0 to 3) 
1CF2:  MOVLW  03
1CF4:  ANDWF  xF5,F
....................  
....................    if (quad == 0 || quad == 2) 
1CF6:  MOVF   xF5,F
1CF8:  BZ    1D00
1CFA:  MOVF   xF5,W
1CFC:  SUBLW  02
1CFE:  BNZ   1D46
1D00:  CLRF   16
1D02:  BTFSC  FF2.7
1D04:  BSF    16.7
1D06:  BCF    FF2.7
....................       t = frac * PI_DIV_BY_TWO; 
1D08:  MOVFF  FA,14D
1D0C:  MOVFF  F9,14C
1D10:  MOVFF  F8,14B
1D14:  MOVFF  F7,14A
1D18:  MOVLW  DB
1D1A:  MOVLB  1
1D1C:  MOVWF  x51
1D1E:  MOVLW  0F
1D20:  MOVWF  x50
1D22:  MOVLW  49
1D24:  MOVWF  x4F
1D26:  MOVLW  7F
1D28:  MOVWF  x4E
1D2A:  MOVLB  0
1D2C:  CALL   018E
1D30:  BTFSC  16.7
1D32:  BSF    FF2.7
1D34:  MOVFF  03,F0
1D38:  MOVFF  02,EF
1D3C:  MOVFF  01,EE
1D40:  MOVFF  00,ED
....................    else if (quad == 1) 
1D44:  BRA    1E54
1D46:  DECFSZ xF5,W
1D48:  BRA    1DD0
....................       t = (1-frac) * PI_DIV_BY_TWO; 
1D4A:  BSF    FD8.1
1D4C:  CLRF   16
1D4E:  BTFSC  FF2.7
1D50:  BSF    16.7
1D52:  BCF    FF2.7
1D54:  MOVLB  1
1D56:  CLRF   x51
1D58:  CLRF   x50
1D5A:  CLRF   x4F
1D5C:  MOVLW  7F
1D5E:  MOVWF  x4E
1D60:  MOVFF  FA,155
1D64:  MOVFF  F9,154
1D68:  MOVFF  F8,153
1D6C:  MOVFF  F7,152
1D70:  MOVLB  0
1D72:  CALL   0418
1D76:  BTFSC  16.7
1D78:  BSF    FF2.7
1D7A:  MOVFF  00,113
1D7E:  MOVFF  01,114
1D82:  MOVFF  02,115
1D86:  MOVFF  03,116
1D8A:  CLRF   16
1D8C:  BTFSC  FF2.7
1D8E:  BSF    16.7
1D90:  BCF    FF2.7
1D92:  MOVFF  03,14D
1D96:  MOVFF  02,14C
1D9A:  MOVFF  01,14B
1D9E:  MOVFF  00,14A
1DA2:  MOVLW  DB
1DA4:  MOVLB  1
1DA6:  MOVWF  x51
1DA8:  MOVLW  0F
1DAA:  MOVWF  x50
1DAC:  MOVLW  49
1DAE:  MOVWF  x4F
1DB0:  MOVLW  7F
1DB2:  MOVWF  x4E
1DB4:  MOVLB  0
1DB6:  CALL   018E
1DBA:  BTFSC  16.7
1DBC:  BSF    FF2.7
1DBE:  MOVFF  03,F0
1DC2:  MOVFF  02,EF
1DC6:  MOVFF  01,EE
1DCA:  MOVFF  00,ED
....................    else // should be 3 
1DCE:  BRA    1E54
....................       t = (frac-1) * PI_DIV_BY_TWO; 
1DD0:  BSF    FD8.1
1DD2:  CLRF   16
1DD4:  BTFSC  FF2.7
1DD6:  BSF    16.7
1DD8:  BCF    FF2.7
1DDA:  MOVFF  FA,151
1DDE:  MOVFF  F9,150
1DE2:  MOVFF  F8,14F
1DE6:  MOVFF  F7,14E
1DEA:  MOVLB  1
1DEC:  CLRF   x55
1DEE:  CLRF   x54
1DF0:  CLRF   x53
1DF2:  MOVLW  7F
1DF4:  MOVWF  x52
1DF6:  MOVLB  0
1DF8:  CALL   0418
1DFC:  BTFSC  16.7
1DFE:  BSF    FF2.7
1E00:  MOVFF  00,113
1E04:  MOVFF  01,114
1E08:  MOVFF  02,115
1E0C:  MOVFF  03,116
1E10:  CLRF   16
1E12:  BTFSC  FF2.7
1E14:  BSF    16.7
1E16:  BCF    FF2.7
1E18:  MOVFF  03,14D
1E1C:  MOVFF  02,14C
1E20:  MOVFF  01,14B
1E24:  MOVFF  00,14A
1E28:  MOVLW  DB
1E2A:  MOVLB  1
1E2C:  MOVWF  x51
1E2E:  MOVLW  0F
1E30:  MOVWF  x50
1E32:  MOVLW  49
1E34:  MOVWF  x4F
1E36:  MOVLW  7F
1E38:  MOVWF  x4E
1E3A:  MOVLB  0
1E3C:  CALL   018E
1E40:  BTFSC  16.7
1E42:  BSF    FF2.7
1E44:  MOVFF  03,F0
1E48:  MOVFF  02,EF
1E4C:  MOVFF  01,EE
1E50:  MOVFF  00,ED
....................  
....................    y = 1.0; 
1E54:  CLRF   xEC
1E56:  CLRF   xEB
1E58:  CLRF   xEA
1E5A:  MOVLW  7F
1E5C:  MOVWF  xE9
1E5E:  CLRF   16
1E60:  BTFSC  FF2.7
1E62:  BSF    16.7
1E64:  BCF    FF2.7
....................    t = t * t; 
1E66:  MOVFF  F0,14D
1E6A:  MOVFF  EF,14C
1E6E:  MOVFF  EE,14B
1E72:  MOVFF  ED,14A
1E76:  MOVFF  F0,151
1E7A:  MOVFF  EF,150
1E7E:  MOVFF  EE,14F
1E82:  MOVFF  ED,14E
1E86:  CALL   018E
1E8A:  BTFSC  16.7
1E8C:  BSF    FF2.7
1E8E:  MOVFF  03,F0
1E92:  MOVFF  02,EF
1E96:  MOVFF  01,EE
1E9A:  MOVFF  00,ED
....................    for (i = 0; i <= 5; i++) 
1E9E:  CLRF   xF6
1EA0:  MOVF   xF6,W
1EA2:  SUBLW  05
1EA4:  BNC   1F8E
1EA6:  CLRF   16
1EA8:  BTFSC  FF2.7
1EAA:  BSF    16.7
1EAC:  BCF    FF2.7
....................    { 
....................       t2 = t2 * t; 
1EAE:  MOVFF  F4,14D
1EB2:  MOVFF  F3,14C
1EB6:  MOVFF  F2,14B
1EBA:  MOVFF  F1,14A
1EBE:  MOVFF  F0,151
1EC2:  MOVFF  EF,150
1EC6:  MOVFF  EE,14F
1ECA:  MOVFF  ED,14E
1ECE:  CALL   018E
1ED2:  BTFSC  16.7
1ED4:  BSF    FF2.7
1ED6:  MOVFF  03,F4
1EDA:  MOVFF  02,F3
1EDE:  MOVFF  01,F2
1EE2:  MOVFF  00,F1
....................       y = y + p[i] * t2; 
1EE6:  MOVF   xF6,W
1EE8:  MULLW  04
1EEA:  MOVF   FF3,W
1EEC:  CLRF   03
1EEE:  ADDLW  FB
1EF0:  MOVWF  FE9
1EF2:  MOVLW  00
1EF4:  ADDWFC 03,W
1EF6:  MOVWF  FEA
1EF8:  MOVFF  FEF,113
1EFC:  MOVFF  FEC,114
1F00:  MOVFF  FEC,115
1F04:  MOVFF  FEC,116
1F08:  CLRF   16
1F0A:  BTFSC  FF2.7
1F0C:  BSF    16.7
1F0E:  BCF    FF2.7
1F10:  MOVFF  116,14D
1F14:  MOVFF  115,14C
1F18:  MOVFF  114,14B
1F1C:  MOVFF  113,14A
1F20:  MOVFF  F4,151
1F24:  MOVFF  F3,150
1F28:  MOVFF  F2,14F
1F2C:  MOVFF  F1,14E
1F30:  CALL   018E
1F34:  BTFSC  16.7
1F36:  BSF    FF2.7
1F38:  MOVFF  FEA,114
1F3C:  MOVFF  FE9,113
1F40:  BCF    FD8.1
1F42:  CLRF   16
1F44:  BTFSC  FF2.7
1F46:  BSF    16.7
1F48:  BCF    FF2.7
1F4A:  MOVFF  EC,151
1F4E:  MOVFF  EB,150
1F52:  MOVFF  EA,14F
1F56:  MOVFF  E9,14E
1F5A:  MOVFF  03,155
1F5E:  MOVFF  02,154
1F62:  MOVFF  01,153
1F66:  MOVFF  00,152
1F6A:  CALL   0418
1F6E:  BTFSC  16.7
1F70:  BSF    FF2.7
1F72:  MOVFF  114,FEA
1F76:  MOVFF  113,FE9
1F7A:  MOVFF  03,EC
1F7E:  MOVFF  02,EB
1F82:  MOVFF  01,EA
1F86:  MOVFF  00,E9
....................    } 
1F8A:  INCF   xF6,F
1F8C:  BRA    1EA0
....................  
....................    if (quad == 2 || quad == 1) 
1F8E:  MOVF   xF5,W
1F90:  SUBLW  02
1F92:  BZ    1F98
1F94:  DECFSZ xF5,W
1F96:  BRA    1F9E
....................       y = -y;  // correct sign 
1F98:  MOVF   xEA,W
1F9A:  XORLW  80
1F9C:  MOVWF  xEA
....................  
....................    return (y); 
1F9E:  MOVFF  E9,00
1FA2:  MOVFF  EA,01
1FA6:  MOVFF  EB,02
1FAA:  MOVFF  EC,03
.................... } 
1FAE:  RETLW  00
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
1FB0:  BSF    FD8.1
1FB2:  CLRF   16
1FB4:  BTFSC  FF2.7
1FB6:  BSF    16.7
1FB8:  BCF    FF2.7
1FBA:  MOVFF  E0,151
1FBE:  MOVFF  DF,150
1FC2:  MOVFF  DE,14F
1FC6:  MOVFF  DD,14E
1FCA:  MOVLW  DB
1FCC:  MOVLB  1
1FCE:  MOVWF  x55
1FD0:  MOVLW  0F
1FD2:  MOVWF  x54
1FD4:  MOVLW  49
1FD6:  MOVWF  x53
1FD8:  MOVLW  7F
1FDA:  MOVWF  x52
1FDC:  MOVLB  0
1FDE:  CALL   0418
1FE2:  BTFSC  16.7
1FE4:  BSF    FF2.7
1FE6:  MOVFF  00,E1
1FEA:  MOVFF  01,E2
1FEE:  MOVFF  02,E3
1FF2:  MOVFF  03,E4
1FF6:  MOVFF  03,E8
1FFA:  MOVFF  02,E7
1FFE:  MOVFF  01,E6
2002:  MOVFF  00,E5
2006:  RCALL  1B7C
.................... } 
2008:  GOTO   21BA (RETURN)
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... #include <string.h> 
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #use delay(clock=20000000) 
.................... #use rs232(uart1,baud=38400,parity=N,Stop=1,bits=8,stream=COM3,errors)//Khai bao su dung uart cung 
*
00BA:  BTFSS  F9E.5
00BC:  BRA    00BA
00BE:  MOVFF  FAB,1D
00C2:  MOVFF  FAE,01
00C6:  BTFSS  1D.1
00C8:  BRA    00CE
00CA:  BCF    FAB.4
00CC:  BSF    FAB.4
00CE:  GOTO   08E4 (RETURN)
.................... #include <string.h>  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... //////////////////// 
.................... #use FAST_IO(A) 
.................... #use FAST_IO(D) 
....................  
.................... #byte PORTA =  0xf80 
.................... #byte PORTB =  0xf81 
.................... #byte PORTC =  0xf82 
.................... #byte PORTD =  0xf83 
.................... #byte PORTE =  0xf84 
.................... #BIT RC1 = PORTC.1 
.................... #BIT RC2 = PORTC.2 
.................... #BIT RE0 = PORTE.0 
.................... #BIT RE2 = PORTE.2 
.................... //////////////// 
.................... #define nguong_right 1000 //nguong PWM 
.................... #define nguong_left 1000   
.................... #define time_step 50535  // 0.005 sencond  5535 // 
.................... #define CHUVI_LEFT 250// chu vi 
.................... #define CHUVI_RIGHT 250 
.................... #define RADIUS 200   //DO RONG XE/2 
.................... ///////////////// 
.................... #define DIR_RIGHT RE0 
.................... #define DIR_LEFT RE2 
.................... #define B RC2 // left ccp2 
.................... #define A RC1 // right cpp1 
.................... void chay(); 
.................... void pid_right(); 
.................... void pid_left(); 
.................... signed int32 countright=0,position_right=0,position_set_right = 0,trunggian=0,count_left; 
.................... signed int32 countleft=0,position_left=0,position_set_left = 0,trunggian1=0; 
.................... signed int32 e_sum_r=0, e_del_r=0, e1_r=0, e2_r=0; 
.................... signed int32 e_sum_l=0, e_del_l=0, e1_l=0, e2_l=0; 
.................... float Kp_r=100, Kd_r=9, Ki_r=0.0001; 
.................... float Kp_l=100, Kd_l=9, Ki_l=0.0001; 
.................... float angle_current = 45; 
.................... float x_cur = 0, y_cur = 0, x_cur_old = 0, y_cur_old = 0; 
.................... int1  copid_right = 1, copid_left = 1 ,codoctinhieu=0,donePID = 0,done_Timer1 = 0; 
.................... ///////////////////////////// 
.................... char  ss,huong; 
.................... char data_receive[50] = ""; 
.................... int8 index = 0,i; 
.................... float value,value_cmd,anpha; 
.................... ////////////////////////////// 
.................... void dichuyen(char huong_move, float value); 
.................... void huongdichuyen(); 
.................... void pid_robot(); 
.................... void xy_vitri(float khoangcach); 
.................... ////////////////////////////// 
....................  
.................... #INT_RDA 
.................... void RDA_isr() 
.................... { 
.................... char value[20]; 
.................... ss=getc(); 
*
08E0:  GOTO   00BA
08E4:  MOVFF  01,8F
....................       if (ss=='A')// begining symbol 
08E8:  MOVF   x8F,W
08EA:  SUBLW  41
08EC:  BNZ   0902
....................       { 
....................       index=0; 
08EE:  CLRF   xC3
....................       *data_receive=""; 
08F0:  CLRF   03
08F2:  MOVLW  91
08F4:  MOVLB  1
08F6:  MOVFF  03,FEA
08FA:  MOVWF  FE9
08FC:  CLRF   FEF
....................       } 
....................       else if (ss=='C') 
08FE:  BRA    09A4
0900:  MOVLB  0
0902:  MOVF   x8F,W
0904:  SUBLW  43
0906:  BNZ   098E
....................       { 
....................       data_receive[index++]='\0'; 
0908:  MOVF   xC3,W
090A:  INCF   xC3,F
090C:  CLRF   03
090E:  ADDLW  91
0910:  MOVWF  FE9
0912:  MOVLW  00
0914:  ADDWFC 03,W
0916:  MOVWF  FEA
0918:  CLRF   FEF
....................       huong = data_receive[0]; 
091A:  MOVFF  91,90
....................      // putc(huong); 
....................       strncpy(value, data_receive + 1, strlen(data_receive) - 1); 
091E:  MOVLB  1
0920:  CLRF   x3C
0922:  MOVLW  91
0924:  MOVWF  x3B
0926:  MOVLB  0
0928:  GOTO   00D2
092C:  MOVLW  01
092E:  SUBWF  01,W
0930:  MOVLB  1
0932:  MOVWF  x3B
0934:  MOVLW  01
0936:  MOVWF  x3D
0938:  MOVLW  27
093A:  MOVWF  x3C
093C:  CLRF   x3F
093E:  MOVLW  92
0940:  MOVWF  x3E
0942:  MOVFF  13B,140
0946:  MOVLB  0
0948:  GOTO   010E
....................       value_cmd=atof(value);     
094C:  MOVLW  01
094E:  MOVLB  1
0950:  MOVWF  x3C
0952:  MOVLW  27
0954:  MOVWF  x3B
0956:  CLRF   x3E
0958:  CLRF   x3D
095A:  MOVLB  0
095C:  BRA    0690
095E:  MOVFF  03,CC
0962:  MOVFF  02,CB
0966:  MOVFF  01,CA
096A:  MOVFF  00,C9
....................      // printf("%f",value_cmd);//he 10 
....................       codoctinhieu= 1; 
096E:  BSF    x8E.2
....................       for (i=0;i<19;i++) 
0970:  CLRF   xC4
0972:  MOVF   xC4,W
0974:  SUBLW  12
0976:  BNC   098C
....................       { 
....................       value[i]=NULL; 
0978:  CLRF   03
097A:  MOVF   xC4,W
097C:  ADDLW  27
097E:  MOVWF  FE9
0980:  MOVLW  01
0982:  ADDWFC 03,W
0984:  MOVWF  FEA
0986:  CLRF   FEF
....................       } 
0988:  INCF   xC4,F
098A:  BRA    0972
....................       } 
....................       else data_receive[index++] = ss;  
098C:  BRA    09A2
098E:  MOVF   xC3,W
0990:  INCF   xC3,F
0992:  CLRF   03
0994:  ADDLW  91
0996:  MOVWF  FE9
0998:  MOVLW  00
099A:  ADDWFC 03,W
099C:  MOVWF  FEA
099E:  MOVFF  8F,FEF
09A2:  MOVLB  1
.................... } 
.................... /////////////////////////////// 
09A4:  BCF    F9E.5
09A6:  MOVLB  0
09A8:  GOTO   0078
.................... #INT_EXT1 
.................... void EXT1_isr() 
.................... { 
....................   disable_interrupts(int_ext1); 
09AC:  BCF    FF0.3
....................    if (input_state(PIN_D1))//qua chieu duong //A-RB1 B-RD1 day vang la B trang la A  
09AE:  BTFSS  F83.1
09B0:  BRA    09E0
....................      {  
....................      countright++; 
09B2:  MOVLW  01
09B4:  ADDWF  1E,F
09B6:  BTFSC  FD8.0
09B8:  INCF   1F,F
09BA:  BTFSC  FD8.2
09BC:  INCF   20,F
09BE:  BTFSC  FD8.2
09C0:  INCF   21,F
....................      if ((huong=='T')||(huong=='F')) count_left++;// de cho no khi 2 banh cung chay 
09C2:  MOVF   x90,W
09C4:  SUBLW  54
09C6:  BZ    09CE
09C8:  MOVF   x90,W
09CA:  SUBLW  46
09CC:  BNZ   09DE
09CE:  MOVLW  01
09D0:  ADDWF  2E,F
09D2:  BTFSC  FD8.0
09D4:  INCF   2F,F
09D6:  BTFSC  FD8.2
09D8:  INCF   30,F
09DA:  BTFSC  FD8.2
09DC:  INCF   31,F
....................      } 
....................    else { 
09DE:  BRA    0A0C
....................    countright--; 
09E0:  MOVLW  FF
09E2:  ADDWF  1E,F
09E4:  BTFSS  FD8.0
09E6:  ADDWF  1F,F
09E8:  BTFSS  FD8.0
09EA:  ADDWF  20,F
09EC:  BTFSS  FD8.0
09EE:  ADDWF  21,F
....................    if ((huong=='T')||(huong=='F')) count_left++;// de cho no khi 2 banh cung chay 
09F0:  MOVF   x90,W
09F2:  SUBLW  54
09F4:  BZ    09FC
09F6:  MOVF   x90,W
09F8:  SUBLW  46
09FA:  BNZ   0A0C
09FC:  MOVLW  01
09FE:  ADDWF  2E,F
0A00:  BTFSC  FD8.0
0A02:  INCF   2F,F
0A04:  BTFSC  FD8.2
0A06:  INCF   30,F
0A08:  BTFSC  FD8.2
0A0A:  INCF   31,F
....................    } 
....................    position_right=countright; 
0A0C:  MOVFF  21,25
0A10:  MOVFF  20,24
0A14:  MOVFF  1F,23
0A18:  MOVFF  1E,22
....................  enable_interrupts(int_ext1); 
0A1C:  BSF    FF0.3
.................... } 
0A1E:  BCF    FF0.0
0A20:  GOTO   0078
.................... #INT_EXT2 
.................... void EXT2_isr() 
.................... { 
....................    disable_interrupts(int_ext2); 
0A24:  BCF    FF0.4
....................    if (input_state(PIN_D2)) 
0A26:  BTFSS  F83.2
0A28:  BRA    0A3C
....................    {    countleft++;   } 
0A2A:  MOVLW  01
0A2C:  ADDWF  32,F
0A2E:  BTFSC  FD8.0
0A30:  INCF   33,F
0A32:  BTFSC  FD8.2
0A34:  INCF   34,F
0A36:  BTFSC  FD8.2
0A38:  INCF   35,F
....................    else   {  countleft--;  } 
0A3A:  BRA    0A4C
0A3C:  MOVLW  FF
0A3E:  ADDWF  32,F
0A40:  BTFSS  FD8.0
0A42:  ADDWF  33,F
0A44:  BTFSS  FD8.0
0A46:  ADDWF  34,F
0A48:  BTFSS  FD8.0
0A4A:  ADDWF  35,F
....................    position_left=countleft; 
0A4C:  MOVFF  35,39
0A50:  MOVFF  34,38
0A54:  MOVFF  33,37
0A58:  MOVFF  32,36
....................    enable_interrupts(int_ext2); 
0A5C:  BSF    FF0.4
.................... } 
0A5E:  BCF    FF0.1
0A60:  GOTO   0078
.................... #INT_TIMER1 
.................... void TIMER1_isr() 
.................... {      done_Timer1 = 1; 
0A64:  BSF    x8E.4
....................        set_timer1(50535); 
0A66:  MOVLW  C5
0A68:  MOVWF  FCF
0A6A:  MOVLW  67
0A6C:  MOVWF  FCE
.................... } 
.................... /**************************************/ 
0A6E:  BCF    F9E.0
0A70:  GOTO   0078
.................... void main(){ 
*
27EA:  CLRF   FF8
27EC:  BCF    FD0.7
27EE:  BSF    07.7
27F0:  CLRF   FEA
27F2:  CLRF   FE9
27F4:  BSF    FB8.3
27F6:  MOVLW  81
27F8:  MOVWF  FAF
27FA:  MOVLW  00
27FC:  MOVWF  FB0
27FE:  MOVLW  A6
2800:  MOVWF  FAC
2802:  MOVLW  90
2804:  MOVWF  FAB
2806:  CLRF   21
2808:  CLRF   20
280A:  CLRF   1F
280C:  CLRF   1E
280E:  CLRF   25
2810:  CLRF   24
2812:  CLRF   23
2814:  CLRF   22
2816:  CLRF   29
2818:  CLRF   28
281A:  CLRF   27
281C:  CLRF   26
281E:  CLRF   2D
2820:  CLRF   2C
2822:  CLRF   2B
2824:  CLRF   2A
2826:  CLRF   35
2828:  CLRF   34
282A:  CLRF   33
282C:  CLRF   32
282E:  CLRF   39
2830:  CLRF   38
2832:  CLRF   37
2834:  CLRF   36
2836:  CLRF   3D
2838:  CLRF   3C
283A:  CLRF   3B
283C:  CLRF   3A
283E:  CLRF   41
2840:  CLRF   40
2842:  CLRF   3F
2844:  CLRF   3E
2846:  CLRF   45
2848:  CLRF   44
284A:  CLRF   43
284C:  CLRF   42
284E:  CLRF   49
2850:  CLRF   48
2852:  CLRF   47
2854:  CLRF   46
2856:  CLRF   4D
2858:  CLRF   4C
285A:  CLRF   4B
285C:  CLRF   4A
285E:  CLRF   51
2860:  CLRF   50
2862:  CLRF   4F
2864:  CLRF   4E
2866:  CLRF   55
2868:  CLRF   54
286A:  CLRF   53
286C:  CLRF   52
286E:  CLRF   59
2870:  CLRF   58
2872:  CLRF   57
2874:  CLRF   56
2876:  CLRF   5D
2878:  CLRF   5C
287A:  CLRF   5B
287C:  CLRF   5A
287E:  CLRF   x61
2880:  CLRF   x60
2882:  CLRF   5F
2884:  CLRF   5E
2886:  CLRF   x65
2888:  CLRF   x64
288A:  MOVLW  48
288C:  MOVWF  x63
288E:  MOVLW  85
2890:  MOVWF  x62
2892:  CLRF   x69
2894:  CLRF   x68
2896:  MOVLW  10
2898:  MOVWF  x67
289A:  MOVLW  82
289C:  MOVWF  x66
289E:  MOVLW  17
28A0:  MOVWF  x6D
28A2:  MOVLW  B7
28A4:  MOVWF  x6C
28A6:  MOVLW  51
28A8:  MOVWF  x6B
28AA:  MOVLW  71
28AC:  MOVWF  x6A
28AE:  CLRF   x71
28B0:  CLRF   x70
28B2:  MOVLW  48
28B4:  MOVWF  x6F
28B6:  MOVLW  85
28B8:  MOVWF  x6E
28BA:  CLRF   x75
28BC:  CLRF   x74
28BE:  MOVLW  10
28C0:  MOVWF  x73
28C2:  MOVLW  82
28C4:  MOVWF  x72
28C6:  MOVLW  17
28C8:  MOVWF  x79
28CA:  MOVLW  B7
28CC:  MOVWF  x78
28CE:  MOVLW  51
28D0:  MOVWF  x77
28D2:  MOVLW  71
28D4:  MOVWF  x76
28D6:  CLRF   x7D
28D8:  CLRF   x7C
28DA:  MOVLW  34
28DC:  MOVWF  x7B
28DE:  MOVLW  84
28E0:  MOVWF  x7A
28E2:  CLRF   x81
28E4:  CLRF   x80
28E6:  CLRF   x7F
28E8:  CLRF   x7E
28EA:  CLRF   x85
28EC:  CLRF   x84
28EE:  CLRF   x83
28F0:  CLRF   x82
28F2:  CLRF   x89
28F4:  CLRF   x88
28F6:  CLRF   x87
28F8:  CLRF   x86
28FA:  CLRF   x8D
28FC:  CLRF   x8C
28FE:  CLRF   x8B
2900:  CLRF   x8A
2902:  BSF    x8E.0
2904:  BSF    x8E.1
2906:  BCF    x8E.2
2908:  BCF    x8E.3
290A:  BCF    x8E.4
290C:  CLRF   xC3
290E:  MOVF   FC1,W
2910:  ANDLW  C0
2912:  IORLW  0F
2914:  MOVWF  FC1
2916:  MOVLW  07
2918:  MOVWF  FB4
291A:  CLRF   17
291C:  CLRF   18
291E:  CLRF   1D
2920:  CLRF   x91
....................  
....................        set_tris_D(0xFF); 
2922:  MOVLW  FF
2924:  MOVWF  F95
....................        set_tris_A(0); 
2926:  MOVLW  00
2928:  MOVWF  F92
....................        set_tris_B(0xFF); 
292A:  MOVLW  FF
292C:  MOVWF  F93
....................      //  set_tris_C(0b10000000); 
....................        set_tris_E(0);    
292E:  MOVLW  00
2930:  MOVWF  F96
....................         set_tris_C(0); 
2932:  MOVWF  F94
....................         setup_adc_ports(NO_ANALOGS); 
2934:  MOVF   FC1,W
2936:  ANDLW  C0
2938:  IORLW  0F
293A:  MOVWF  FC1
....................        setup_timer_1(T1_INTERNAL | T1_DIV_BY_1 ); 
293C:  MOVLW  85
293E:  MOVWF  FCD
....................        set_timer1(50535);  
2940:  MOVLW  C5
2942:  MOVWF  FCF
2944:  MOVLW  67
2946:  MOVWF  FCE
....................        setup_timer_2(T2_DIV_BY_4,255,1);  //f_pwm = 2.9 Khz, T_pwm = 4.(PR2+1).Tosc.Pre-scale 
2948:  MOVLW  00
294A:  IORLW  05
294C:  MOVWF  FCA
294E:  MOVLW  FF
2950:  MOVWF  FCB
....................        output_low(PIN_C1); // Set CCP2 output low  
2952:  BCF    F94.1
2954:  BCF    F8B.1
....................        output_low(PIN_C2); // Set CCP1 output low  
2956:  BCF    F94.2
2958:  BCF    F8B.2
....................        
....................        setup_ccp1(CCP_PWM);    //khoi tao bo PWM1 
295A:  BCF    F94.2
295C:  BCF    F8B.2
295E:  BCF    F96.6
2960:  MOVLW  0C
2962:  MOVWF  FBD
2964:  CLRF   FB7
2966:  CLRF   FB6
....................        setup_ccp2(CCP_PWM);    //khoi tao bo PWM2 
2968:  BCF    F94.1
296A:  BCF    F8B.1
296C:  MOVWF  FBA
....................        set_pwm1_duty(0);      //PIN_C2, Right motor 
296E:  CLRF   FBE
....................        set_pwm2_duty(0);      //PIN_C1, Left motor 
2970:  CLRF   FBB
....................        
....................        enable_interrupts(INT_RDA);  
2972:  BSF    F9D.5
....................        enable_interrupts(int_ext1); 
2974:  BSF    FF0.3
....................        enable_interrupts(int_ext2); 
2976:  BSF    FF0.4
....................        ext_int_edge(1, H_TO_L ); 
2978:  BCF    FF1.5
....................        ext_int_edge(2, H_TO_L ); 
297A:  BCF    FF1.4
....................        enable_interrupts(INT_TIMER1);    
297C:  BSF    F9D.0
....................        enable_interrupts(GLOBAL);    
297E:  MOVLW  C0
2980:  IORWF  FF2,F
....................        A=1; 
2982:  BSF    F82.1
....................        B=1; 
2984:  BSF    F82.2
....................             output_low(pin_A0); 
2986:  BCF    F89.0
.................... while(true) 
.................... { 
....................    if (done_Timer1 == 1) 
2988:  BTFSS  x8E.4
298A:  BRA    29A8
....................    { 
....................       dichuyen(huong,value_cmd); 
298C:  MOVFF  90,D1
2990:  MOVFF  CC,D5
2994:  MOVFF  CB,D4
2998:  MOVFF  CA,D3
299C:  MOVFF  C9,D2
29A0:  GOTO   0AB2
....................     pid_robot(); 
29A4:  BRA    24A6
....................      done_Timer1 =0;     
29A6:  BCF    x8E.4
....................    } 
.................... } 
29A8:  BRA    2988
.................... } 
.................... void pid_robot() 
.................... { 
29AA:  SLEEP 
....................       pid_right(); 
*
24A6:  GOTO   14F4
....................       pid_left(); 
24AA:  GOTO   17FA
....................       if ((copid_right)&&(copid_left)&&(!donePID)) 
24AE:  BTFSS  x8E.0
24B0:  BRA    27E6
24B2:  BTFSS  x8E.1
24B4:  BRA    27E6
24B6:  BTFSC  x8E.3
24B8:  BRA    27E6
....................       { 
....................        
....................        if (huong=='R') 
24BA:  MOVF   x90,W
24BC:  SUBLW  52
24BE:  BNZ   2506
....................       { 
....................         angle_current =angle_current - value_cmd; 
24C0:  BSF    FD8.1
24C2:  CLRF   16
24C4:  BTFSC  FF2.7
24C6:  BSF    16.7
24C8:  BCF    FF2.7
24CA:  MOVFF  7D,151
24CE:  MOVFF  7C,150
24D2:  MOVFF  7B,14F
24D6:  MOVFF  7A,14E
24DA:  MOVFF  CC,155
24DE:  MOVFF  CB,154
24E2:  MOVFF  CA,153
24E6:  MOVFF  C9,152
24EA:  CALL   0418
24EE:  BTFSC  16.7
24F0:  BSF    FF2.7
24F2:  MOVFF  03,7D
24F6:  MOVFF  02,7C
24FA:  MOVFF  01,7B
24FE:  MOVFF  00,7A
....................         huong = ""; 
2502:  CLRF   x90
....................        } 
....................        else if (huong=='L') 
2504:  BRA    2598
2506:  MOVF   x90,W
2508:  SUBLW  4C
250A:  BNZ   2552
....................         { 
....................              angle_current  =angle_current + value_cmd; 
250C:  BCF    FD8.1
250E:  CLRF   16
2510:  BTFSC  FF2.7
2512:  BSF    16.7
2514:  BCF    FF2.7
2516:  MOVFF  7D,151
251A:  MOVFF  7C,150
251E:  MOVFF  7B,14F
2522:  MOVFF  7A,14E
2526:  MOVFF  CC,155
252A:  MOVFF  CB,154
252E:  MOVFF  CA,153
2532:  MOVFF  C9,152
2536:  CALL   0418
253A:  BTFSC  16.7
253C:  BSF    FF2.7
253E:  MOVFF  03,7D
2542:  MOVFF  02,7C
2546:  MOVFF  01,7B
254A:  MOVFF  00,7A
....................             huong = ""; 
254E:  CLRF   x90
....................         } 
....................         else if (huong=='F') 
2550:  BRA    2598
2552:  MOVF   x90,W
2554:  SUBLW  46
2556:  BNZ   256E
....................         { 
....................               xy_vitri(value_cmd); 
2558:  MOVFF  CC,D8
255C:  MOVFF  CB,D7
2560:  MOVFF  CA,D6
2564:  MOVFF  C9,D5
2568:  RCALL  200C
....................                huong = ""; 
256A:  CLRF   x90
....................         } 
....................         else if (huong=='B') 
256C:  BRA    2598
256E:  MOVF   x90,W
2570:  SUBLW  42
2572:  BNZ   2598
....................         { 
....................              xy_vitri(-value_cmd); 
2574:  MOVFF  C9,D1
2578:  MOVF   xCA,W
257A:  XORLW  80
257C:  MOVWF  xD2
257E:  MOVFF  CB,D3
2582:  MOVFF  CC,D4
2586:  MOVFF  CC,D8
258A:  MOVFF  CB,D7
258E:  MOVWF  xD6
2590:  MOVFF  C9,D5
2594:  RCALL  200C
....................                huong = ""; 
2596:  CLRF   x90
....................         } 
....................     if (angle_current >= 360.0) angle_current =angle_current -360.0; 
2598:  MOVLB  1
259A:  CLRF   x16
259C:  CLRF   x15
259E:  MOVLW  34
25A0:  MOVWF  x14
25A2:  MOVLW  87
25A4:  MOVWF  x13
25A6:  MOVFF  7D,11A
25AA:  MOVFF  7C,119
25AE:  MOVFF  7B,118
25B2:  MOVFF  7A,117
25B6:  MOVLB  0
25B8:  CALL   1B02
25BC:  BC    25C0
25BE:  BNZ   2602
25C0:  BSF    FD8.1
25C2:  CLRF   16
25C4:  BTFSC  FF2.7
25C6:  BSF    16.7
25C8:  BCF    FF2.7
25CA:  MOVFF  7D,151
25CE:  MOVFF  7C,150
25D2:  MOVFF  7B,14F
25D6:  MOVFF  7A,14E
25DA:  MOVLB  1
25DC:  CLRF   x55
25DE:  CLRF   x54
25E0:  MOVLW  34
25E2:  MOVWF  x53
25E4:  MOVLW  87
25E6:  MOVWF  x52
25E8:  MOVLB  0
25EA:  CALL   0418
25EE:  BTFSC  16.7
25F0:  BSF    FF2.7
25F2:  MOVFF  03,7D
25F6:  MOVFF  02,7C
25FA:  MOVFF  01,7B
25FE:  MOVFF  00,7A
....................     if (angle_current < 0 ) angle_current =angle_current + 360.0; 
2602:  MOVFF  7D,116
2606:  MOVFF  7C,115
260A:  MOVFF  7B,114
260E:  MOVFF  7A,113
2612:  MOVLB  1
2614:  CLRF   x1A
2616:  CLRF   x19
2618:  CLRF   x18
261A:  CLRF   x17
261C:  MOVLB  0
261E:  CALL   1B02
2622:  BNC   2666
2624:  BCF    FD8.1
2626:  CLRF   16
2628:  BTFSC  FF2.7
262A:  BSF    16.7
262C:  BCF    FF2.7
262E:  MOVFF  7D,151
2632:  MOVFF  7C,150
2636:  MOVFF  7B,14F
263A:  MOVFF  7A,14E
263E:  MOVLB  1
2640:  CLRF   x55
2642:  CLRF   x54
2644:  MOVLW  34
2646:  MOVWF  x53
2648:  MOVLW  87
264A:  MOVWF  x52
264C:  MOVLB  0
264E:  CALL   0418
2652:  BTFSC  16.7
2654:  BSF    FF2.7
2656:  MOVFF  03,7D
265A:  MOVFF  02,7C
265E:  MOVFF  01,7B
2662:  MOVFF  00,7A
....................     x_cur= (int32 )x_cur; 
2666:  MOVFF  81,E1
266A:  MOVFF  80,E0
266E:  MOVFF  7F,DF
2672:  MOVFF  7E,DE
2676:  CALL   0A74
267A:  MOVFF  03,D4
267E:  MOVFF  02,D3
2682:  MOVFF  01,D2
2686:  MOVFF  00,D1
268A:  RCALL  225E
268C:  MOVFF  03,81
2690:  MOVFF  02,80
2694:  MOVFF  01,7F
2698:  MOVFF  00,7E
....................     y_cur= (int32)y_cur; 
269C:  MOVFF  85,E1
26A0:  MOVFF  84,E0
26A4:  MOVFF  83,DF
26A8:  MOVFF  82,DE
26AC:  CALL   0A74
26B0:  MOVFF  03,D4
26B4:  MOVFF  02,D3
26B8:  MOVFF  01,D2
26BC:  MOVFF  00,D1
26C0:  RCALL  225E
26C2:  MOVFF  03,85
26C6:  MOVFF  02,84
26CA:  MOVFF  01,83
26CE:  MOVFF  00,82
....................    angle_current= (int32) angle_current;  
26D2:  MOVFF  7D,E1
26D6:  MOVFF  7C,E0
26DA:  MOVFF  7B,DF
26DE:  MOVFF  7A,DE
26E2:  CALL   0A74
26E6:  MOVFF  03,D4
26EA:  MOVFF  02,D3
26EE:  MOVFF  01,D2
26F2:  MOVFF  00,D1
26F6:  RCALL  225E
26F8:  MOVFF  03,7D
26FC:  MOVFF  02,7C
2700:  MOVFF  01,7B
2704:  MOVFF  00,7A
....................   printf("X%fY%fZ%fBX%fY%fZ%fB", x_cur, y_cur, angle_current,x_cur, y_cur, angle_current); 
2708:  MOVLW  58
270A:  BTFSS  F9E.4
270C:  BRA    270A
270E:  MOVWF  FAD
2710:  MOVLW  89
2712:  MOVWF  FE9
2714:  MOVFF  81,D4
2718:  MOVFF  80,D3
271C:  MOVFF  7F,D2
2720:  MOVFF  7E,D1
2724:  MOVLW  02
2726:  MOVWF  xD5
2728:  RCALL  230C
272A:  MOVLW  59
272C:  BTFSS  F9E.4
272E:  BRA    272C
2730:  MOVWF  FAD
2732:  MOVLW  89
2734:  MOVWF  FE9
2736:  MOVFF  85,D4
273A:  MOVFF  84,D3
273E:  MOVFF  83,D2
2742:  MOVFF  82,D1
2746:  MOVLW  02
2748:  MOVWF  xD5
274A:  RCALL  230C
274C:  MOVLW  5A
274E:  BTFSS  F9E.4
2750:  BRA    274E
2752:  MOVWF  FAD
2754:  MOVLW  89
2756:  MOVWF  FE9
2758:  MOVFF  7D,D4
275C:  MOVFF  7C,D3
2760:  MOVFF  7B,D2
2764:  MOVFF  7A,D1
2768:  MOVLW  02
276A:  MOVWF  xD5
276C:  RCALL  230C
276E:  MOVLW  42
2770:  BTFSS  F9E.4
2772:  BRA    2770
2774:  MOVWF  FAD
2776:  MOVLW  58
2778:  BTFSS  F9E.4
277A:  BRA    2778
277C:  MOVWF  FAD
277E:  MOVLW  89
2780:  MOVWF  FE9
2782:  MOVFF  81,D4
2786:  MOVFF  80,D3
278A:  MOVFF  7F,D2
278E:  MOVFF  7E,D1
2792:  MOVLW  02
2794:  MOVWF  xD5
2796:  RCALL  230C
2798:  MOVLW  59
279A:  BTFSS  F9E.4
279C:  BRA    279A
279E:  MOVWF  FAD
27A0:  MOVLW  89
27A2:  MOVWF  FE9
27A4:  MOVFF  85,D4
27A8:  MOVFF  84,D3
27AC:  MOVFF  83,D2
27B0:  MOVFF  82,D1
27B4:  MOVLW  02
27B6:  MOVWF  xD5
27B8:  RCALL  230C
27BA:  MOVLW  5A
27BC:  BTFSS  F9E.4
27BE:  BRA    27BC
27C0:  MOVWF  FAD
27C2:  MOVLW  89
27C4:  MOVWF  FE9
27C6:  MOVFF  7D,D4
27CA:  MOVFF  7C,D3
27CE:  MOVFF  7B,D2
27D2:  MOVFF  7A,D1
27D6:  MOVLW  02
27D8:  MOVWF  xD5
27DA:  RCALL  230C
27DC:  MOVLW  42
27DE:  BTFSS  F9E.4
27E0:  BRA    27DE
27E2:  MOVWF  FAD
....................     donePID = 1;        
27E4:  BSF    x8E.3
....................      } 
.................... } 
27E6:  GOTO   29A6 (RETURN)
.................... void xy_vitri(float khoangcach) 
.................... { 
*
200C:  CLRF   16
200E:  BTFSC  FF2.7
2010:  BSF    16.7
2012:  BCF    FF2.7
....................  x_cur = x_cur_old + khoangcach*cos(angle_current*PI/180.0); 
2014:  MOVFF  7D,14D
2018:  MOVFF  7C,14C
201C:  MOVFF  7B,14B
2020:  MOVFF  7A,14A
2024:  MOVLW  DB
2026:  MOVLB  1
2028:  MOVWF  x51
202A:  MOVLW  0F
202C:  MOVWF  x50
202E:  MOVLW  49
2030:  MOVWF  x4F
2032:  MOVLW  80
2034:  MOVWF  x4E
2036:  MOVLB  0
2038:  CALL   018E
203C:  BTFSC  16.7
203E:  BSF    FF2.7
2040:  MOVFF  00,D9
2044:  MOVFF  01,DA
2048:  MOVFF  02,DB
204C:  MOVFF  03,DC
2050:  CLRF   16
2052:  BTFSC  FF2.7
2054:  BSF    16.7
2056:  BCF    FF2.7
2058:  MOVFF  03,151
205C:  MOVFF  02,150
2060:  MOVFF  01,14F
2064:  MOVFF  00,14E
2068:  MOVLB  1
206A:  CLRF   x55
206C:  CLRF   x54
206E:  MOVLW  34
2070:  MOVWF  x53
2072:  MOVLW  86
2074:  MOVWF  x52
2076:  MOVLB  0
2078:  CALL   02BA
207C:  BTFSC  16.7
207E:  BSF    FF2.7
2080:  MOVFF  00,D9
2084:  MOVFF  01,DA
2088:  MOVFF  02,DB
208C:  MOVFF  03,DC
2090:  MOVFF  03,E8
2094:  MOVFF  02,E7
2098:  MOVFF  01,E6
209C:  MOVFF  00,E5
20A0:  RCALL  1B7C
20A2:  CLRF   16
20A4:  BTFSC  FF2.7
20A6:  BSF    16.7
20A8:  BCF    FF2.7
20AA:  MOVFF  D8,14D
20AE:  MOVFF  D7,14C
20B2:  MOVFF  D6,14B
20B6:  MOVFF  D5,14A
20BA:  MOVFF  03,151
20BE:  MOVFF  02,150
20C2:  MOVFF  01,14F
20C6:  MOVFF  00,14E
20CA:  CALL   018E
20CE:  BTFSC  16.7
20D0:  BSF    FF2.7
20D2:  MOVFF  FEA,DA
20D6:  MOVFF  FE9,D9
20DA:  BCF    FD8.1
20DC:  CLRF   16
20DE:  BTFSC  FF2.7
20E0:  BSF    16.7
20E2:  BCF    FF2.7
20E4:  MOVFF  89,151
20E8:  MOVFF  88,150
20EC:  MOVFF  87,14F
20F0:  MOVFF  86,14E
20F4:  MOVFF  03,155
20F8:  MOVFF  02,154
20FC:  MOVFF  01,153
2100:  MOVFF  00,152
2104:  CALL   0418
2108:  BTFSC  16.7
210A:  BSF    FF2.7
210C:  MOVFF  DA,FEA
2110:  MOVFF  D9,FE9
2114:  MOVFF  03,81
2118:  MOVFF  02,80
211C:  MOVFF  01,7F
2120:  MOVFF  00,7E
2124:  CLRF   16
2126:  BTFSC  FF2.7
2128:  BSF    16.7
212A:  BCF    FF2.7
....................  y_cur = y_cur_old + khoangcach*sin(angle_current*PI/180.0); 
212C:  MOVFF  7D,14D
2130:  MOVFF  7C,14C
2134:  MOVFF  7B,14B
2138:  MOVFF  7A,14A
213C:  MOVLW  DB
213E:  MOVLB  1
2140:  MOVWF  x51
2142:  MOVLW  0F
2144:  MOVWF  x50
2146:  MOVLW  49
2148:  MOVWF  x4F
214A:  MOVLW  80
214C:  MOVWF  x4E
214E:  MOVLB  0
2150:  CALL   018E
2154:  BTFSC  16.7
2156:  BSF    FF2.7
2158:  MOVFF  00,D9
215C:  MOVFF  01,DA
2160:  MOVFF  02,DB
2164:  MOVFF  03,DC
2168:  CLRF   16
216A:  BTFSC  FF2.7
216C:  BSF    16.7
216E:  BCF    FF2.7
2170:  MOVFF  03,151
2174:  MOVFF  02,150
2178:  MOVFF  01,14F
217C:  MOVFF  00,14E
2180:  MOVLB  1
2182:  CLRF   x55
2184:  CLRF   x54
2186:  MOVLW  34
2188:  MOVWF  x53
218A:  MOVLW  86
218C:  MOVWF  x52
218E:  MOVLB  0
2190:  CALL   02BA
2194:  BTFSC  16.7
2196:  BSF    FF2.7
2198:  MOVFF  00,D9
219C:  MOVFF  01,DA
21A0:  MOVFF  02,DB
21A4:  MOVFF  03,DC
21A8:  MOVFF  03,E0
21AC:  MOVFF  02,DF
21B0:  MOVFF  01,DE
21B4:  MOVFF  00,DD
21B8:  BRA    1FB0
21BA:  CLRF   16
21BC:  BTFSC  FF2.7
21BE:  BSF    16.7
21C0:  BCF    FF2.7
21C2:  MOVFF  D8,14D
21C6:  MOVFF  D7,14C
21CA:  MOVFF  D6,14B
21CE:  MOVFF  D5,14A
21D2:  MOVFF  03,151
21D6:  MOVFF  02,150
21DA:  MOVFF  01,14F
21DE:  MOVFF  00,14E
21E2:  CALL   018E
21E6:  BTFSC  16.7
21E8:  BSF    FF2.7
21EA:  MOVFF  FEA,DA
21EE:  MOVFF  FE9,D9
21F2:  BCF    FD8.1
21F4:  CLRF   16
21F6:  BTFSC  FF2.7
21F8:  BSF    16.7
21FA:  BCF    FF2.7
21FC:  MOVFF  8D,151
2200:  MOVFF  8C,150
2204:  MOVFF  8B,14F
2208:  MOVFF  8A,14E
220C:  MOVFF  03,155
2210:  MOVFF  02,154
2214:  MOVFF  01,153
2218:  MOVFF  00,152
221C:  CALL   0418
2220:  BTFSC  16.7
2222:  BSF    FF2.7
2224:  MOVFF  DA,FEA
2228:  MOVFF  D9,FE9
222C:  MOVFF  03,85
2230:  MOVFF  02,84
2234:  MOVFF  01,83
2238:  MOVFF  00,82
....................  x_cur_old = x_cur; 
223C:  MOVFF  81,89
2240:  MOVFF  80,88
2244:  MOVFF  7F,87
2248:  MOVFF  7E,86
....................  y_cur_old = y_cur;  
224C:  MOVFF  85,8D
2250:  MOVFF  84,8C
2254:  MOVFF  83,8B
2258:  MOVFF  82,8A
.................... } 
225C:  RETLW  00
.................... void dichuyen(char huong_move, float value) 
.................... { 
....................   if (codoctinhieu==1) 
*
0AB2:  BTFSS  x8E.2
0AB4:  GOTO   145E
....................       { 
....................       copid_right=0; 
0AB8:  BCF    x8E.0
....................       copid_left=0; 
0ABA:  BCF    x8E.1
....................       donePID = 0; 
0ABC:  BCF    x8E.3
....................        
....................       countright = 0; 
0ABE:  CLRF   21
0AC0:  CLRF   20
0AC2:  CLRF   1F
0AC4:  CLRF   1E
....................       countleft = 0; 
0AC6:  CLRF   35
0AC8:  CLRF   34
0ACA:  CLRF   33
0ACC:  CLRF   32
....................       position_left = 0; 
0ACE:  CLRF   39
0AD0:  CLRF   38
0AD2:  CLRF   37
0AD4:  CLRF   36
....................       position_right = 0; 
0AD6:  CLRF   25
0AD8:  CLRF   24
0ADA:  CLRF   23
0ADC:  CLRF   22
....................       codoctinhieu=0; 
0ADE:  BCF    x8E.2
....................        switch (huong_move) 
....................       { 
0AE0:  MOVF   xD1,W
0AE2:  XORLW  54
0AE4:  BZ    0B08
0AE6:  XORLW  07
0AE8:  BTFSC  FD8.2
0AEA:  BRA    0C38
0AEC:  XORLW  15
0AEE:  BTFSC  FD8.2
0AF0:  BRA    0D5E
0AF2:  XORLW  04
0AF4:  BTFSC  FD8.2
0AF6:  BRA    0E8C
0AF8:  XORLW  10
0AFA:  BTFSC  FD8.2
0AFC:  BRA    0FB2
0AFE:  XORLW  1E
0B00:  BTFSC  FD8.2
0B02:  BRA    120E
0B04:  GOTO   145C
....................       case 'T': 
0B08:  CLRF   16
0B0A:  BTFSC  FF2.7
0B0C:  BSF    16.7
0B0E:  BCF    FF2.7
....................       { 
....................          position_set_left  = (unsigned int32)(100.0*value/CHUVI_LEFT); 
0B10:  MOVLB  1
0B12:  CLRF   x4D
0B14:  CLRF   x4C
0B16:  MOVLW  48
0B18:  MOVWF  x4B
0B1A:  MOVLW  85
0B1C:  MOVWF  x4A
0B1E:  MOVFF  D5,151
0B22:  MOVFF  D4,150
0B26:  MOVFF  D3,14F
0B2A:  MOVFF  D2,14E
0B2E:  MOVLB  0
0B30:  CALL   018E
0B34:  BTFSC  16.7
0B36:  BSF    FF2.7
0B38:  MOVFF  00,D6
0B3C:  MOVFF  01,D7
0B40:  MOVFF  02,D8
0B44:  MOVFF  03,D9
0B48:  CLRF   16
0B4A:  BTFSC  FF2.7
0B4C:  BSF    16.7
0B4E:  BCF    FF2.7
0B50:  MOVFF  03,151
0B54:  MOVFF  02,150
0B58:  MOVFF  01,14F
0B5C:  MOVFF  00,14E
0B60:  MOVLB  1
0B62:  CLRF   x55
0B64:  CLRF   x54
0B66:  MOVLW  7A
0B68:  MOVWF  x53
0B6A:  MOVLW  86
0B6C:  MOVWF  x52
0B6E:  MOVLB  0
0B70:  CALL   02BA
0B74:  BTFSC  16.7
0B76:  BSF    FF2.7
0B78:  MOVFF  03,E1
0B7C:  MOVFF  02,E0
0B80:  MOVFF  01,DF
0B84:  MOVFF  00,DE
0B88:  RCALL  0A74
0B8A:  MOVFF  03,3D
0B8E:  MOVFF  02,3C
0B92:  MOVFF  01,3B
0B96:  MOVFF  00,3A
0B9A:  CLRF   16
0B9C:  BTFSC  FF2.7
0B9E:  BSF    16.7
0BA0:  BCF    FF2.7
....................          position_set_right = (unsigned int32)(100.0*value/CHUVI_RIGHT); 
0BA2:  MOVLB  1
0BA4:  CLRF   x4D
0BA6:  CLRF   x4C
0BA8:  MOVLW  48
0BAA:  MOVWF  x4B
0BAC:  MOVLW  85
0BAE:  MOVWF  x4A
0BB0:  MOVFF  D5,151
0BB4:  MOVFF  D4,150
0BB8:  MOVFF  D3,14F
0BBC:  MOVFF  D2,14E
0BC0:  MOVLB  0
0BC2:  CALL   018E
0BC6:  BTFSC  16.7
0BC8:  BSF    FF2.7
0BCA:  MOVFF  00,D6
0BCE:  MOVFF  01,D7
0BD2:  MOVFF  02,D8
0BD6:  MOVFF  03,D9
0BDA:  CLRF   16
0BDC:  BTFSC  FF2.7
0BDE:  BSF    16.7
0BE0:  BCF    FF2.7
0BE2:  MOVFF  03,151
0BE6:  MOVFF  02,150
0BEA:  MOVFF  01,14F
0BEE:  MOVFF  00,14E
0BF2:  MOVLB  1
0BF4:  CLRF   x55
0BF6:  CLRF   x54
0BF8:  MOVLW  7A
0BFA:  MOVWF  x53
0BFC:  MOVLW  86
0BFE:  MOVWF  x52
0C00:  MOVLB  0
0C02:  CALL   02BA
0C06:  BTFSC  16.7
0C08:  BSF    FF2.7
0C0A:  MOVFF  03,E1
0C0E:  MOVFF  02,E0
0C12:  MOVFF  01,DF
0C16:  MOVFF  00,DE
0C1A:  RCALL  0A74
0C1C:  MOVFF  03,29
0C20:  MOVFF  02,28
0C24:  MOVFF  01,27
0C28:  MOVFF  00,26
....................          count_left=0; 
0C2C:  CLRF   31
0C2E:  CLRF   30
0C30:  CLRF   2F
0C32:  CLRF   2E
....................          break; 
0C34:  GOTO   145E
....................       } 
....................       case 'S': 
0C38:  CLRF   16
0C3A:  BTFSC  FF2.7
0C3C:  BSF    16.7
0C3E:  BCF    FF2.7
....................       { 
....................           position_set_left  = (unsigned int32)(100.0*value/CHUVI_LEFT); 
0C40:  MOVLB  1
0C42:  CLRF   x4D
0C44:  CLRF   x4C
0C46:  MOVLW  48
0C48:  MOVWF  x4B
0C4A:  MOVLW  85
0C4C:  MOVWF  x4A
0C4E:  MOVFF  D5,151
0C52:  MOVFF  D4,150
0C56:  MOVFF  D3,14F
0C5A:  MOVFF  D2,14E
0C5E:  MOVLB  0
0C60:  CALL   018E
0C64:  BTFSC  16.7
0C66:  BSF    FF2.7
0C68:  MOVFF  00,D6
0C6C:  MOVFF  01,D7
0C70:  MOVFF  02,D8
0C74:  MOVFF  03,D9
0C78:  CLRF   16
0C7A:  BTFSC  FF2.7
0C7C:  BSF    16.7
0C7E:  BCF    FF2.7
0C80:  MOVFF  03,151
0C84:  MOVFF  02,150
0C88:  MOVFF  01,14F
0C8C:  MOVFF  00,14E
0C90:  MOVLB  1
0C92:  CLRF   x55
0C94:  CLRF   x54
0C96:  MOVLW  7A
0C98:  MOVWF  x53
0C9A:  MOVLW  86
0C9C:  MOVWF  x52
0C9E:  MOVLB  0
0CA0:  CALL   02BA
0CA4:  BTFSC  16.7
0CA6:  BSF    FF2.7
0CA8:  MOVFF  03,E1
0CAC:  MOVFF  02,E0
0CB0:  MOVFF  01,DF
0CB4:  MOVFF  00,DE
0CB8:  RCALL  0A74
0CBA:  MOVFF  03,3D
0CBE:  MOVFF  02,3C
0CC2:  MOVFF  01,3B
0CC6:  MOVFF  00,3A
0CCA:  CLRF   16
0CCC:  BTFSC  FF2.7
0CCE:  BSF    16.7
0CD0:  BCF    FF2.7
....................           position_set_right = (unsigned int32)(100.0*value/CHUVI_RIGHT); 
0CD2:  MOVLB  1
0CD4:  CLRF   x4D
0CD6:  CLRF   x4C
0CD8:  MOVLW  48
0CDA:  MOVWF  x4B
0CDC:  MOVLW  85
0CDE:  MOVWF  x4A
0CE0:  MOVFF  D5,151
0CE4:  MOVFF  D4,150
0CE8:  MOVFF  D3,14F
0CEC:  MOVFF  D2,14E
0CF0:  MOVLB  0
0CF2:  CALL   018E
0CF6:  BTFSC  16.7
0CF8:  BSF    FF2.7
0CFA:  MOVFF  00,D6
0CFE:  MOVFF  01,D7
0D02:  MOVFF  02,D8
0D06:  MOVFF  03,D9
0D0A:  CLRF   16
0D0C:  BTFSC  FF2.7
0D0E:  BSF    16.7
0D10:  BCF    FF2.7
0D12:  MOVFF  03,151
0D16:  MOVFF  02,150
0D1A:  MOVFF  01,14F
0D1E:  MOVFF  00,14E
0D22:  MOVLB  1
0D24:  CLRF   x55
0D26:  CLRF   x54
0D28:  MOVLW  7A
0D2A:  MOVWF  x53
0D2C:  MOVLW  86
0D2E:  MOVWF  x52
0D30:  MOVLB  0
0D32:  CALL   02BA
0D36:  BTFSC  16.7
0D38:  BSF    FF2.7
0D3A:  MOVFF  03,E1
0D3E:  MOVFF  02,E0
0D42:  MOVFF  01,DF
0D46:  MOVFF  00,DE
0D4A:  RCALL  0A74
0D4C:  MOVFF  03,29
0D50:  MOVFF  02,28
0D54:  MOVFF  01,27
0D58:  MOVFF  00,26
....................           break; 
0D5C:  BRA    145E
....................       } 
....................       case 'F': 
0D5E:  CLRF   16
0D60:  BTFSC  FF2.7
0D62:  BSF    16.7
0D64:  BCF    FF2.7
....................       { 
....................           position_set_left  = (unsigned int32)(100.0*value/CHUVI_LEFT); 
0D66:  MOVLB  1
0D68:  CLRF   x4D
0D6A:  CLRF   x4C
0D6C:  MOVLW  48
0D6E:  MOVWF  x4B
0D70:  MOVLW  85
0D72:  MOVWF  x4A
0D74:  MOVFF  D5,151
0D78:  MOVFF  D4,150
0D7C:  MOVFF  D3,14F
0D80:  MOVFF  D2,14E
0D84:  MOVLB  0
0D86:  CALL   018E
0D8A:  BTFSC  16.7
0D8C:  BSF    FF2.7
0D8E:  MOVFF  00,D6
0D92:  MOVFF  01,D7
0D96:  MOVFF  02,D8
0D9A:  MOVFF  03,D9
0D9E:  CLRF   16
0DA0:  BTFSC  FF2.7
0DA2:  BSF    16.7
0DA4:  BCF    FF2.7
0DA6:  MOVFF  03,151
0DAA:  MOVFF  02,150
0DAE:  MOVFF  01,14F
0DB2:  MOVFF  00,14E
0DB6:  MOVLB  1
0DB8:  CLRF   x55
0DBA:  CLRF   x54
0DBC:  MOVLW  7A
0DBE:  MOVWF  x53
0DC0:  MOVLW  86
0DC2:  MOVWF  x52
0DC4:  MOVLB  0
0DC6:  CALL   02BA
0DCA:  BTFSC  16.7
0DCC:  BSF    FF2.7
0DCE:  MOVFF  03,E1
0DD2:  MOVFF  02,E0
0DD6:  MOVFF  01,DF
0DDA:  MOVFF  00,DE
0DDE:  RCALL  0A74
0DE0:  MOVFF  03,3D
0DE4:  MOVFF  02,3C
0DE8:  MOVFF  01,3B
0DEC:  MOVFF  00,3A
0DF0:  CLRF   16
0DF2:  BTFSC  FF2.7
0DF4:  BSF    16.7
0DF6:  BCF    FF2.7
....................           position_set_right = (unsigned int32)(100.0*value/CHUVI_RIGHT);   
0DF8:  MOVLB  1
0DFA:  CLRF   x4D
0DFC:  CLRF   x4C
0DFE:  MOVLW  48
0E00:  MOVWF  x4B
0E02:  MOVLW  85
0E04:  MOVWF  x4A
0E06:  MOVFF  D5,151
0E0A:  MOVFF  D4,150
0E0E:  MOVFF  D3,14F
0E12:  MOVFF  D2,14E
0E16:  MOVLB  0
0E18:  CALL   018E
0E1C:  BTFSC  16.7
0E1E:  BSF    FF2.7
0E20:  MOVFF  00,D6
0E24:  MOVFF  01,D7
0E28:  MOVFF  02,D8
0E2C:  MOVFF  03,D9
0E30:  CLRF   16
0E32:  BTFSC  FF2.7
0E34:  BSF    16.7
0E36:  BCF    FF2.7
0E38:  MOVFF  03,151
0E3C:  MOVFF  02,150
0E40:  MOVFF  01,14F
0E44:  MOVFF  00,14E
0E48:  MOVLB  1
0E4A:  CLRF   x55
0E4C:  CLRF   x54
0E4E:  MOVLW  7A
0E50:  MOVWF  x53
0E52:  MOVLW  86
0E54:  MOVWF  x52
0E56:  MOVLB  0
0E58:  CALL   02BA
0E5C:  BTFSC  16.7
0E5E:  BSF    FF2.7
0E60:  MOVFF  03,E1
0E64:  MOVFF  02,E0
0E68:  MOVFF  01,DF
0E6C:  MOVFF  00,DE
0E70:  RCALL  0A74
0E72:  MOVFF  03,29
0E76:  MOVFF  02,28
0E7A:  MOVFF  01,27
0E7E:  MOVFF  00,26
....................           count_left=0; 
0E82:  CLRF   31
0E84:  CLRF   30
0E86:  CLRF   2F
0E88:  CLRF   2E
....................           break; 
0E8A:  BRA    145E
....................       } 
....................       case 'B': 
0E8C:  CLRF   16
0E8E:  BTFSC  FF2.7
0E90:  BSF    16.7
0E92:  BCF    FF2.7
....................       { 
....................        position_set_left  =  (unsigned int32)(-100.0*value/CHUVI_LEFT); 
0E94:  MOVLB  1
0E96:  CLRF   x4D
0E98:  CLRF   x4C
0E9A:  MOVLW  C8
0E9C:  MOVWF  x4B
0E9E:  MOVLW  85
0EA0:  MOVWF  x4A
0EA2:  MOVFF  D5,151
0EA6:  MOVFF  D4,150
0EAA:  MOVFF  D3,14F
0EAE:  MOVFF  D2,14E
0EB2:  MOVLB  0
0EB4:  CALL   018E
0EB8:  BTFSC  16.7
0EBA:  BSF    FF2.7
0EBC:  MOVFF  00,D6
0EC0:  MOVFF  01,D7
0EC4:  MOVFF  02,D8
0EC8:  MOVFF  03,D9
0ECC:  CLRF   16
0ECE:  BTFSC  FF2.7
0ED0:  BSF    16.7
0ED2:  BCF    FF2.7
0ED4:  MOVFF  03,151
0ED8:  MOVFF  02,150
0EDC:  MOVFF  01,14F
0EE0:  MOVFF  00,14E
0EE4:  MOVLB  1
0EE6:  CLRF   x55
0EE8:  CLRF   x54
0EEA:  MOVLW  7A
0EEC:  MOVWF  x53
0EEE:  MOVLW  86
0EF0:  MOVWF  x52
0EF2:  MOVLB  0
0EF4:  CALL   02BA
0EF8:  BTFSC  16.7
0EFA:  BSF    FF2.7
0EFC:  MOVFF  03,E1
0F00:  MOVFF  02,E0
0F04:  MOVFF  01,DF
0F08:  MOVFF  00,DE
0F0C:  RCALL  0A74
0F0E:  MOVFF  03,3D
0F12:  MOVFF  02,3C
0F16:  MOVFF  01,3B
0F1A:  MOVFF  00,3A
0F1E:  CLRF   16
0F20:  BTFSC  FF2.7
0F22:  BSF    16.7
0F24:  BCF    FF2.7
....................         position_set_right =  (unsigned int32)(-100.0*value/CHUVI_RIGHT); 
0F26:  MOVLB  1
0F28:  CLRF   x4D
0F2A:  CLRF   x4C
0F2C:  MOVLW  C8
0F2E:  MOVWF  x4B
0F30:  MOVLW  85
0F32:  MOVWF  x4A
0F34:  MOVFF  D5,151
0F38:  MOVFF  D4,150
0F3C:  MOVFF  D3,14F
0F40:  MOVFF  D2,14E
0F44:  MOVLB  0
0F46:  CALL   018E
0F4A:  BTFSC  16.7
0F4C:  BSF    FF2.7
0F4E:  MOVFF  00,D6
0F52:  MOVFF  01,D7
0F56:  MOVFF  02,D8
0F5A:  MOVFF  03,D9
0F5E:  CLRF   16
0F60:  BTFSC  FF2.7
0F62:  BSF    16.7
0F64:  BCF    FF2.7
0F66:  MOVFF  03,151
0F6A:  MOVFF  02,150
0F6E:  MOVFF  01,14F
0F72:  MOVFF  00,14E
0F76:  MOVLB  1
0F78:  CLRF   x55
0F7A:  CLRF   x54
0F7C:  MOVLW  7A
0F7E:  MOVWF  x53
0F80:  MOVLW  86
0F82:  MOVWF  x52
0F84:  MOVLB  0
0F86:  CALL   02BA
0F8A:  BTFSC  16.7
0F8C:  BSF    FF2.7
0F8E:  MOVFF  03,E1
0F92:  MOVFF  02,E0
0F96:  MOVFF  01,DF
0F9A:  MOVFF  00,DE
0F9E:  RCALL  0A74
0FA0:  MOVFF  03,29
0FA4:  MOVFF  02,28
0FA8:  MOVFF  01,27
0FAC:  MOVFF  00,26
....................         break; 
0FB0:  BRA    145E
....................       } 
....................       case 'R': 
....................       { 
....................        anpha = - value*10*3.1415/180.0;    
0FB2:  MOVFF  D2,D6
0FB6:  MOVF   xD3,W
0FB8:  XORLW  80
0FBA:  MOVWF  xD7
0FBC:  MOVFF  D4,D8
0FC0:  MOVFF  D5,D9
0FC4:  CLRF   16
0FC6:  BTFSC  FF2.7
0FC8:  BSF    16.7
0FCA:  BCF    FF2.7
0FCC:  MOVFF  D5,14D
0FD0:  MOVFF  D4,14C
0FD4:  MOVFF  FE8,14B
0FD8:  MOVFF  D2,14A
0FDC:  MOVLB  1
0FDE:  CLRF   x51
0FE0:  CLRF   x50
0FE2:  MOVLW  20
0FE4:  MOVWF  x4F
0FE6:  MOVLW  82
0FE8:  MOVWF  x4E
0FEA:  MOVLB  0
0FEC:  CALL   018E
0FF0:  BTFSC  16.7
0FF2:  BSF    FF2.7
0FF4:  MOVFF  00,D6
0FF8:  MOVFF  01,D7
0FFC:  MOVFF  02,D8
1000:  MOVFF  03,D9
1004:  CLRF   16
1006:  BTFSC  FF2.7
1008:  BSF    16.7
100A:  BCF    FF2.7
100C:  MOVFF  03,14D
1010:  MOVFF  02,14C
1014:  MOVFF  01,14B
1018:  MOVFF  00,14A
101C:  MOVLW  56
101E:  MOVLB  1
1020:  MOVWF  x51
1022:  MOVLW  0E
1024:  MOVWF  x50
1026:  MOVLW  49
1028:  MOVWF  x4F
102A:  MOVLW  80
102C:  MOVWF  x4E
102E:  MOVLB  0
1030:  CALL   018E
1034:  BTFSC  16.7
1036:  BSF    FF2.7
1038:  MOVFF  00,D6
103C:  MOVFF  01,D7
1040:  MOVFF  02,D8
1044:  MOVFF  03,D9
1048:  CLRF   16
104A:  BTFSC  FF2.7
104C:  BSF    16.7
104E:  BCF    FF2.7
1050:  MOVFF  03,151
1054:  MOVFF  02,150
1058:  MOVFF  01,14F
105C:  MOVFF  00,14E
1060:  MOVLB  1
1062:  CLRF   x55
1064:  CLRF   x54
1066:  MOVLW  34
1068:  MOVWF  x53
106A:  MOVLW  86
106C:  MOVWF  x52
106E:  MOVLB  0
1070:  CALL   02BA
1074:  BTFSC  16.7
1076:  BSF    FF2.7
1078:  MOVFF  03,D0
107C:  MOVFF  02,CF
1080:  MOVFF  01,CE
1084:  MOVFF  00,CD
1088:  CLRF   16
108A:  BTFSC  FF2.7
108C:  BSF    16.7
108E:  BCF    FF2.7
....................        position_set_left  =  (unsigned int32)(-100.0*(anpha*RADIUS)/CHUVI_LEFT); 
1090:  MOVFF  D0,14D
1094:  MOVFF  CF,14C
1098:  MOVFF  CE,14B
109C:  MOVFF  CD,14A
10A0:  MOVLB  1
10A2:  CLRF   x51
10A4:  CLRF   x50
10A6:  MOVLW  48
10A8:  MOVWF  x4F
10AA:  MOVLW  86
10AC:  MOVWF  x4E
10AE:  MOVLB  0
10B0:  CALL   018E
10B4:  BTFSC  16.7
10B6:  BSF    FF2.7
10B8:  CLRF   16
10BA:  BTFSC  FF2.7
10BC:  BSF    16.7
10BE:  BCF    FF2.7
10C0:  MOVLB  1
10C2:  CLRF   x4D
10C4:  CLRF   x4C
10C6:  MOVLW  C8
10C8:  MOVWF  x4B
10CA:  MOVLW  85
10CC:  MOVWF  x4A
10CE:  MOVFF  03,151
10D2:  MOVFF  02,150
10D6:  MOVFF  01,14F
10DA:  MOVFF  00,14E
10DE:  MOVLB  0
10E0:  CALL   018E
10E4:  BTFSC  16.7
10E6:  BSF    FF2.7
10E8:  MOVFF  00,D6
10EC:  MOVFF  01,D7
10F0:  MOVFF  02,D8
10F4:  MOVFF  03,D9
10F8:  CLRF   16
10FA:  BTFSC  FF2.7
10FC:  BSF    16.7
10FE:  BCF    FF2.7
1100:  MOVFF  03,151
1104:  MOVFF  02,150
1108:  MOVFF  01,14F
110C:  MOVFF  00,14E
1110:  MOVLB  1
1112:  CLRF   x55
1114:  CLRF   x54
1116:  MOVLW  7A
1118:  MOVWF  x53
111A:  MOVLW  86
111C:  MOVWF  x52
111E:  MOVLB  0
1120:  CALL   02BA
1124:  BTFSC  16.7
1126:  BSF    FF2.7
1128:  MOVFF  03,E1
112C:  MOVFF  02,E0
1130:  MOVFF  01,DF
1134:  MOVFF  00,DE
1138:  RCALL  0A74
113A:  MOVFF  03,3D
113E:  MOVFF  02,3C
1142:  MOVFF  01,3B
1146:  MOVFF  00,3A
114A:  CLRF   16
114C:  BTFSC  FF2.7
114E:  BSF    16.7
1150:  BCF    FF2.7
....................        position_set_right =  (unsigned int32)(100.0*(anpha*RADIUS)/CHUVI_RIGHT); 
1152:  MOVFF  D0,14D
1156:  MOVFF  CF,14C
115A:  MOVFF  CE,14B
115E:  MOVFF  CD,14A
1162:  MOVLB  1
1164:  CLRF   x51
1166:  CLRF   x50
1168:  MOVLW  48
116A:  MOVWF  x4F
116C:  MOVLW  86
116E:  MOVWF  x4E
1170:  MOVLB  0
1172:  CALL   018E
1176:  BTFSC  16.7
1178:  BSF    FF2.7
117A:  CLRF   16
117C:  BTFSC  FF2.7
117E:  BSF    16.7
1180:  BCF    FF2.7
1182:  MOVLB  1
1184:  CLRF   x4D
1186:  CLRF   x4C
1188:  MOVLW  48
118A:  MOVWF  x4B
118C:  MOVLW  85
118E:  MOVWF  x4A
1190:  MOVFF  03,151
1194:  MOVFF  02,150
1198:  MOVFF  01,14F
119C:  MOVFF  00,14E
11A0:  MOVLB  0
11A2:  CALL   018E
11A6:  BTFSC  16.7
11A8:  BSF    FF2.7
11AA:  MOVFF  00,D6
11AE:  MOVFF  01,D7
11B2:  MOVFF  02,D8
11B6:  MOVFF  03,D9
11BA:  CLRF   16
11BC:  BTFSC  FF2.7
11BE:  BSF    16.7
11C0:  BCF    FF2.7
11C2:  MOVFF  03,151
11C6:  MOVFF  02,150
11CA:  MOVFF  01,14F
11CE:  MOVFF  00,14E
11D2:  MOVLB  1
11D4:  CLRF   x55
11D6:  CLRF   x54
11D8:  MOVLW  7A
11DA:  MOVWF  x53
11DC:  MOVLW  86
11DE:  MOVWF  x52
11E0:  MOVLB  0
11E2:  CALL   02BA
11E6:  BTFSC  16.7
11E8:  BSF    FF2.7
11EA:  MOVFF  03,E1
11EE:  MOVFF  02,E0
11F2:  MOVFF  01,DF
11F6:  MOVFF  00,DE
11FA:  RCALL  0A74
11FC:  MOVFF  03,29
1200:  MOVFF  02,28
1204:  MOVFF  01,27
1208:  MOVFF  00,26
....................        
....................         break; 
120C:  BRA    145E
....................       } 
....................       case 'L': 
120E:  CLRF   16
1210:  BTFSC  FF2.7
1212:  BSF    16.7
1214:  BCF    FF2.7
....................       { 
....................         anpha = 10*value*3.1415/180.0;      
1216:  MOVLB  1
1218:  CLRF   x4D
121A:  CLRF   x4C
121C:  MOVLW  20
121E:  MOVWF  x4B
1220:  MOVLW  82
1222:  MOVWF  x4A
1224:  MOVFF  D5,151
1228:  MOVFF  D4,150
122C:  MOVFF  D3,14F
1230:  MOVFF  D2,14E
1234:  MOVLB  0
1236:  CALL   018E
123A:  BTFSC  16.7
123C:  BSF    FF2.7
123E:  MOVFF  00,D6
1242:  MOVFF  01,D7
1246:  MOVFF  02,D8
124A:  MOVFF  03,D9
124E:  CLRF   16
1250:  BTFSC  FF2.7
1252:  BSF    16.7
1254:  BCF    FF2.7
1256:  MOVFF  03,14D
125A:  MOVFF  02,14C
125E:  MOVFF  01,14B
1262:  MOVFF  00,14A
1266:  MOVLW  56
1268:  MOVLB  1
126A:  MOVWF  x51
126C:  MOVLW  0E
126E:  MOVWF  x50
1270:  MOVLW  49
1272:  MOVWF  x4F
1274:  MOVLW  80
1276:  MOVWF  x4E
1278:  MOVLB  0
127A:  CALL   018E
127E:  BTFSC  16.7
1280:  BSF    FF2.7
1282:  MOVFF  00,D6
1286:  MOVFF  01,D7
128A:  MOVFF  02,D8
128E:  MOVFF  03,D9
1292:  CLRF   16
1294:  BTFSC  FF2.7
1296:  BSF    16.7
1298:  BCF    FF2.7
129A:  MOVFF  03,151
129E:  MOVFF  02,150
12A2:  MOVFF  01,14F
12A6:  MOVFF  00,14E
12AA:  MOVLB  1
12AC:  CLRF   x55
12AE:  CLRF   x54
12B0:  MOVLW  34
12B2:  MOVWF  x53
12B4:  MOVLW  86
12B6:  MOVWF  x52
12B8:  MOVLB  0
12BA:  CALL   02BA
12BE:  BTFSC  16.7
12C0:  BSF    FF2.7
12C2:  MOVFF  03,D0
12C6:  MOVFF  02,CF
12CA:  MOVFF  01,CE
12CE:  MOVFF  00,CD
12D2:  CLRF   16
12D4:  BTFSC  FF2.7
12D6:  BSF    16.7
12D8:  BCF    FF2.7
....................         position_set_left  =  (unsigned int32)(-100.0*(anpha*RADIUS)/CHUVI_LEFT);//so xung doc encorder 
12DA:  MOVFF  D0,14D
12DE:  MOVFF  CF,14C
12E2:  MOVFF  CE,14B
12E6:  MOVFF  CD,14A
12EA:  MOVLB  1
12EC:  CLRF   x51
12EE:  CLRF   x50
12F0:  MOVLW  48
12F2:  MOVWF  x4F
12F4:  MOVLW  86
12F6:  MOVWF  x4E
12F8:  MOVLB  0
12FA:  CALL   018E
12FE:  BTFSC  16.7
1300:  BSF    FF2.7
1302:  CLRF   16
1304:  BTFSC  FF2.7
1306:  BSF    16.7
1308:  BCF    FF2.7
130A:  MOVLB  1
130C:  CLRF   x4D
130E:  CLRF   x4C
1310:  MOVLW  C8
1312:  MOVWF  x4B
1314:  MOVLW  85
1316:  MOVWF  x4A
1318:  MOVFF  03,151
131C:  MOVFF  02,150
1320:  MOVFF  01,14F
1324:  MOVFF  00,14E
1328:  MOVLB  0
132A:  CALL   018E
132E:  BTFSC  16.7
1330:  BSF    FF2.7
1332:  MOVFF  00,D6
1336:  MOVFF  01,D7
133A:  MOVFF  02,D8
133E:  MOVFF  03,D9
1342:  CLRF   16
1344:  BTFSC  FF2.7
1346:  BSF    16.7
1348:  BCF    FF2.7
134A:  MOVFF  03,151
134E:  MOVFF  02,150
1352:  MOVFF  01,14F
1356:  MOVFF  00,14E
135A:  MOVLB  1
135C:  CLRF   x55
135E:  CLRF   x54
1360:  MOVLW  7A
1362:  MOVWF  x53
1364:  MOVLW  86
1366:  MOVWF  x52
1368:  MOVLB  0
136A:  CALL   02BA
136E:  BTFSC  16.7
1370:  BSF    FF2.7
1372:  MOVFF  03,E1
1376:  MOVFF  02,E0
137A:  MOVFF  01,DF
137E:  MOVFF  00,DE
1382:  CALL   0A74
1386:  MOVFF  03,3D
138A:  MOVFF  02,3C
138E:  MOVFF  01,3B
1392:  MOVFF  00,3A
1396:  CLRF   16
1398:  BTFSC  FF2.7
139A:  BSF    16.7
139C:  BCF    FF2.7
....................         position_set_right =  (unsigned int32)(100.0*(anpha*RADIUS)/CHUVI_RIGHT); 
139E:  MOVFF  D0,14D
13A2:  MOVFF  CF,14C
13A6:  MOVFF  CE,14B
13AA:  MOVFF  CD,14A
13AE:  MOVLB  1
13B0:  CLRF   x51
13B2:  CLRF   x50
13B4:  MOVLW  48
13B6:  MOVWF  x4F
13B8:  MOVLW  86
13BA:  MOVWF  x4E
13BC:  MOVLB  0
13BE:  CALL   018E
13C2:  BTFSC  16.7
13C4:  BSF    FF2.7
13C6:  CLRF   16
13C8:  BTFSC  FF2.7
13CA:  BSF    16.7
13CC:  BCF    FF2.7
13CE:  MOVLB  1
13D0:  CLRF   x4D
13D2:  CLRF   x4C
13D4:  MOVLW  48
13D6:  MOVWF  x4B
13D8:  MOVLW  85
13DA:  MOVWF  x4A
13DC:  MOVFF  03,151
13E0:  MOVFF  02,150
13E4:  MOVFF  01,14F
13E8:  MOVFF  00,14E
13EC:  MOVLB  0
13EE:  CALL   018E
13F2:  BTFSC  16.7
13F4:  BSF    FF2.7
13F6:  MOVFF  00,D6
13FA:  MOVFF  01,D7
13FE:  MOVFF  02,D8
1402:  MOVFF  03,D9
1406:  CLRF   16
1408:  BTFSC  FF2.7
140A:  BSF    16.7
140C:  BCF    FF2.7
140E:  MOVFF  03,151
1412:  MOVFF  02,150
1416:  MOVFF  01,14F
141A:  MOVFF  00,14E
141E:  MOVLB  1
1420:  CLRF   x55
1422:  CLRF   x54
1424:  MOVLW  7A
1426:  MOVWF  x53
1428:  MOVLW  86
142A:  MOVWF  x52
142C:  MOVLB  0
142E:  CALL   02BA
1432:  BTFSC  16.7
1434:  BSF    FF2.7
1436:  MOVFF  03,E1
143A:  MOVFF  02,E0
143E:  MOVFF  01,DF
1442:  MOVFF  00,DE
1446:  CALL   0A74
144A:  MOVFF  03,29
144E:  MOVFF  02,28
1452:  MOVFF  01,27
1456:  MOVFF  00,26
....................         break;          
145A:  BRA    145E
....................       
....................       } 
....................        default:  break; 
145C:  BRA    145E
....................       } 
....................       } 
....................        
.................... } 
145E:  GOTO   29A4 (RETURN)
.................... void pid_left() 
.................... { 
....................  
....................   B=1; 
*
17FA:  BSF    F82.2
....................     signed int16 temp_kp = 0; 
....................   signed int16 temp_ki = 0; 
....................   signed int16 temp_kd = 0; 
....................   signed int16 pw_duty_Left_Temp = 0; 
17FC:  CLRF   xD2
17FE:  CLRF   xD1
1800:  CLRF   xD4
1802:  CLRF   xD3
1804:  CLRF   xD6
1806:  CLRF   xD5
1808:  CLRF   xD8
180A:  CLRF   xD7
....................   e2_l= position_set_left - position_left; 
180C:  MOVF   36,W
180E:  SUBWF  3A,W
1810:  MOVWF  5E
1812:  MOVF   37,W
1814:  SUBWFB 3B,W
1816:  MOVWF  5F
1818:  MOVF   38,W
181A:  SUBWFB 3C,W
181C:  MOVWF  x60
181E:  MOVF   39,W
1820:  SUBWFB 3D,W
1822:  MOVWF  x61
....................   e_sum_l+=e2_l; 
1824:  MOVF   5E,W
1826:  ADDWF  52,F
1828:  MOVF   5F,W
182A:  ADDWFC 53,F
182C:  MOVF   x60,W
182E:  ADDWFC 54,F
1830:  MOVF   x61,W
1832:  ADDWFC 55,F
....................   e_del_l=e2_l-e1_l; 
1834:  MOVF   5A,W
1836:  SUBWF  5E,W
1838:  MOVWF  56
183A:  MOVF   5B,W
183C:  SUBWFB 5F,W
183E:  MOVWF  57
1840:  MOVF   5C,W
1842:  SUBWFB x60,W
1844:  MOVWF  58
1846:  MOVF   5D,W
1848:  SUBWFB x61,W
184A:  MOVWF  59
....................   e1_l=e2_l; 
184C:  MOVFF  61,5D
1850:  MOVFF  60,5C
1854:  MOVFF  5F,5B
1858:  MOVFF  5E,5A
....................    temp_kp = (signed int16)((float)kp_l*e2_l); 
185C:  MOVFF  61,DC
1860:  MOVFF  60,DB
1864:  MOVFF  5F,DA
1868:  MOVFF  5E,D9
186C:  RCALL  1462
186E:  CLRF   16
1870:  BTFSC  FF2.7
1872:  BSF    16.7
1874:  BCF    FF2.7
1876:  MOVFF  71,14D
187A:  MOVFF  70,14C
187E:  MOVFF  6F,14B
1882:  MOVFF  6E,14A
1886:  MOVFF  03,151
188A:  MOVFF  02,150
188E:  MOVFF  01,14F
1892:  MOVFF  00,14E
1896:  CALL   018E
189A:  BTFSC  16.7
189C:  BSF    FF2.7
189E:  MOVFF  03,116
18A2:  MOVFF  02,115
18A6:  MOVFF  01,114
18AA:  MOVFF  00,113
18AE:  RCALL  14B8
18B0:  MOVFF  02,D2
18B4:  MOVFF  01,D1
....................    temp_ki = (signed int16)((float)ki_l*e_sum_l); 
18B8:  MOVFF  55,DC
18BC:  MOVFF  54,DB
18C0:  MOVFF  53,DA
18C4:  MOVFF  52,D9
18C8:  RCALL  1462
18CA:  CLRF   16
18CC:  BTFSC  FF2.7
18CE:  BSF    16.7
18D0:  BCF    FF2.7
18D2:  MOVFF  79,14D
18D6:  MOVFF  78,14C
18DA:  MOVFF  77,14B
18DE:  MOVFF  76,14A
18E2:  MOVFF  03,151
18E6:  MOVFF  02,150
18EA:  MOVFF  01,14F
18EE:  MOVFF  00,14E
18F2:  CALL   018E
18F6:  BTFSC  16.7
18F8:  BSF    FF2.7
18FA:  MOVFF  03,116
18FE:  MOVFF  02,115
1902:  MOVFF  01,114
1906:  MOVFF  00,113
190A:  RCALL  14B8
190C:  MOVFF  02,D4
1910:  MOVFF  01,D3
....................    temp_kd = (signed int16)((float)kd_l*e_del_l); 
1914:  MOVFF  59,DC
1918:  MOVFF  58,DB
191C:  MOVFF  57,DA
1920:  MOVFF  56,D9
1924:  RCALL  1462
1926:  CLRF   16
1928:  BTFSC  FF2.7
192A:  BSF    16.7
192C:  BCF    FF2.7
192E:  MOVFF  75,14D
1932:  MOVFF  74,14C
1936:  MOVFF  73,14B
193A:  MOVFF  72,14A
193E:  MOVFF  03,151
1942:  MOVFF  02,150
1946:  MOVFF  01,14F
194A:  MOVFF  00,14E
194E:  CALL   018E
1952:  BTFSC  16.7
1954:  BSF    FF2.7
1956:  MOVFF  03,116
195A:  MOVFF  02,115
195E:  MOVFF  01,114
1962:  MOVFF  00,113
1966:  RCALL  14B8
1968:  MOVFF  02,D6
196C:  MOVFF  01,D5
....................    
....................    pw_duty_Left_Temp = (signed int16)(temp_kp + temp_ki + temp_kd); 
1970:  MOVF   xD3,W
1972:  ADDWF  xD1,W
1974:  MOVWF  xD9
1976:  MOVF   xD4,W
1978:  ADDWFC xD2,W
197A:  MOVWF  xDA
197C:  MOVF   xD5,W
197E:  ADDWF  xD9,W
1980:  MOVWF  xD7
1982:  MOVF   xD6,W
1984:  ADDWFC xDA,W
1986:  MOVWF  xD8
....................    if ( pw_duty_Left_Temp > nguong_left) 
1988:  BTFSC  xD8.7
198A:  BRA    19A4
198C:  MOVF   xD8,W
198E:  SUBLW  02
1990:  BC    19A4
1992:  XORLW  FF
1994:  BNZ   199C
1996:  MOVF   xD7,W
1998:  SUBLW  E8
199A:  BC    19A4
....................    { 
....................    pw_duty_Left_Temp=nguong_left; 
199C:  MOVLW  03
199E:  MOVWF  xD8
19A0:  MOVLW  E8
19A2:  MOVWF  xD7
....................    } 
....................    if (pw_duty_Left_Temp < - nguong_left) 
19A4:  BTFSS  xD8.7
19A6:  BRA    19BE
19A8:  MOVF   xD8,W
19AA:  SUBLW  FC
19AC:  BNC   19BE
19AE:  BNZ   19B6
19B0:  MOVF   xD7,W
19B2:  SUBLW  17
19B4:  BNC   19BE
....................    { 
....................    pw_duty_Left_Temp=-nguong_left; 
19B6:  MOVLW  FC
19B8:  MOVWF  xD8
19BA:  MOVLW  18
19BC:  MOVWF  xD7
....................    } 
....................    if ( pw_duty_Left_Temp>0) 
19BE:  BTFSC  xD8.7
19C0:  BRA    19F8
19C2:  MOVF   xD8,F
19C4:  BNZ   19CC
19C6:  MOVF   xD7,W
19C8:  SUBLW  00
19CA:  BC    19F8
....................    { 
....................    output_high(pin_A0); 
19CC:  BSF    F89.0
....................    DIR_LEFT=1; 
19CE:  BSF    F84.2
....................     set_pwm2_duty(pw_duty_Left_Temp); 
19D0:  MOVFF  D8,02
19D4:  MOVFF  D7,01
19D8:  RRCF   02,F
19DA:  RRCF   01,F
19DC:  RRCF   02,F
19DE:  RRCF   01,F
19E0:  RRCF   02,F
19E2:  MOVFF  01,FBB
19E6:  RRCF   02,F
19E8:  RRCF   02,W
19EA:  ANDLW  30
19EC:  MOVWF  00
19EE:  MOVF   FBA,W
19F0:  ANDLW  CF
19F2:  IORWF  00,W
19F4:  MOVWF  FBA
....................    } 
....................    else  
19F6:  BRA    1A5C
....................    { 
....................     DIR_LEFT=0; 
19F8:  BCF    F84.2
....................     trunggian1=abs(pw_duty_Left_Temp); 
19FA:  MOVFF  D8,03
19FE:  MOVF   xD7,W
1A00:  BTFSS  xD8.7
1A02:  BRA    1A14
1A04:  MOVLW  00
1A06:  BSF    FD8.0
1A08:  SUBFWB xD7,W
1A0A:  MOVWF  00
1A0C:  MOVLW  00
1A0E:  SUBFWB xD8,W
1A10:  MOVWF  03
1A12:  MOVF   00,W
1A14:  MOVWF  00
1A16:  MOVFF  03,01
1A1A:  CLRF   02
1A1C:  CLRF   03
1A1E:  BTFSS  01.7
1A20:  BRA    1A26
1A22:  DECF   02,F
1A24:  DECF   03,F
1A26:  MOVFF  03,41
1A2A:  MOVFF  02,40
1A2E:  MOVFF  01,3F
1A32:  MOVFF  00,3E
....................     set_pwm2_duty( trunggian1);    
1A36:  MOVFF  3F,02
1A3A:  MOVFF  3E,01
1A3E:  RRCF   02,F
1A40:  RRCF   01,F
1A42:  RRCF   02,F
1A44:  RRCF   01,F
1A46:  RRCF   02,F
1A48:  MOVFF  01,FBB
1A4C:  RRCF   02,F
1A4E:  RRCF   02,W
1A50:  ANDLW  30
1A52:  MOVWF  00
1A54:  MOVF   FBA,W
1A56:  ANDLW  CF
1A58:  IORWF  00,W
1A5A:  MOVWF  FBA
....................    }  
....................    if ((huong=='L')||(huong=='R')) 
1A5C:  MOVF   x90,W
1A5E:  SUBLW  4C
1A60:  BZ    1A68
1A62:  MOVF   x90,W
1A64:  SUBLW  52
1A66:  BNZ   1AB4
....................       { 
....................       if((e2_l>-100)&&(e2_l<100)) 
1A68:  BTFSS  x61.7
1A6A:  BRA    1A90
1A6C:  MOVF   x61,W
1A6E:  SUBLW  FE
1A70:  BC    1AB0
1A72:  XORLW  FF
1A74:  BNZ   1A90
1A76:  MOVF   x60,W
1A78:  SUBLW  FE
1A7A:  BC    1AB0
1A7C:  XORLW  FF
1A7E:  BNZ   1A90
1A80:  MOVF   5F,W
1A82:  SUBLW  FE
1A84:  BC    1AB0
1A86:  XORLW  FF
1A88:  BNZ   1A90
1A8A:  MOVF   5E,W
1A8C:  SUBLW  9C
1A8E:  BC    1AB0
1A90:  BTFSC  x61.7
1A92:  BRA    1AA6
1A94:  MOVF   x61,F
1A96:  BNZ   1AB0
1A98:  MOVF   x60,F
1A9A:  BNZ   1AB0
1A9C:  MOVF   5F,F
1A9E:  BNZ   1AB0
1AA0:  MOVF   5E,W
1AA2:  SUBLW  63
1AA4:  BNC   1AB0
....................    { 
....................    B=0; 
1AA6:  BCF    F82.2
....................     DIR_LEFT=0; 
1AA8:  BCF    F84.2
....................     set_pwm2_duty( 0); 
1AAA:  CLRF   FBB
....................     copid_left=1; 
1AAC:  BSF    x8E.1
....................    }  
....................    else  
1AAE:  BRA    1AB2
....................    { 
....................    copid_left=0; 
1AB0:  BCF    x8E.1
....................    } 
....................       } 
....................       //////////// 
....................     else 
1AB2:  BRA    1AFE
....................     { 
....................    if((e2_l>-40)&&(e2_l<40)) 
1AB4:  BTFSS  x61.7
1AB6:  BRA    1ADC
1AB8:  MOVF   x61,W
1ABA:  SUBLW  FE
1ABC:  BC    1AFC
1ABE:  XORLW  FF
1AC0:  BNZ   1ADC
1AC2:  MOVF   x60,W
1AC4:  SUBLW  FE
1AC6:  BC    1AFC
1AC8:  XORLW  FF
1ACA:  BNZ   1ADC
1ACC:  MOVF   5F,W
1ACE:  SUBLW  FE
1AD0:  BC    1AFC
1AD2:  XORLW  FF
1AD4:  BNZ   1ADC
1AD6:  MOVF   5E,W
1AD8:  SUBLW  D8
1ADA:  BC    1AFC
1ADC:  BTFSC  x61.7
1ADE:  BRA    1AF2
1AE0:  MOVF   x61,F
1AE2:  BNZ   1AFC
1AE4:  MOVF   x60,F
1AE6:  BNZ   1AFC
1AE8:  MOVF   5F,F
1AEA:  BNZ   1AFC
1AEC:  MOVF   5E,W
1AEE:  SUBLW  27
1AF0:  BNC   1AFC
....................    { 
....................     DIR_LEFT=0; 
1AF2:  BCF    F84.2
....................     B=0; 
1AF4:  BCF    F82.2
....................     set_pwm2_duty( 0); 
1AF6:  CLRF   FBB
....................     copid_left=1; 
1AF8:  BSF    x8E.1
....................    }  
....................    else  
1AFA:  BRA    1AFE
....................    { 
....................    copid_left=0; 
1AFC:  BCF    x8E.1
....................    } 
....................     } 
....................   
.................... } 
1AFE:  GOTO   24AE (RETURN)
.................... void pid_right() 
.................... { 
....................  
.................... A=1; 
*
14F4:  BSF    F82.1
....................   signed int16 temp_kp = 0; 
....................   signed int16 temp_ki = 0; 
....................   signed int16 temp_kd = 0; 
....................   signed int16 pw_duty_Right_Temp = 0; 
14F6:  CLRF   xD2
14F8:  CLRF   xD1
14FA:  CLRF   xD4
14FC:  CLRF   xD3
14FE:  CLRF   xD6
1500:  CLRF   xD5
1502:  CLRF   xD8
1504:  CLRF   xD7
....................  
....................   e2_r= position_set_right- position_right; 
1506:  MOVF   22,W
1508:  SUBWF  26,W
150A:  MOVWF  4E
150C:  MOVF   23,W
150E:  SUBWFB 27,W
1510:  MOVWF  4F
1512:  MOVF   24,W
1514:  SUBWFB 28,W
1516:  MOVWF  50
1518:  MOVF   25,W
151A:  SUBWFB 29,W
151C:  MOVWF  51
....................   e_sum_r+=e2_r; 
151E:  MOVF   4E,W
1520:  ADDWF  42,F
1522:  MOVF   4F,W
1524:  ADDWFC 43,F
1526:  MOVF   50,W
1528:  ADDWFC 44,F
152A:  MOVF   51,W
152C:  ADDWFC 45,F
....................   e_del_r=e2_r-e1_r; 
152E:  MOVF   4A,W
1530:  SUBWF  4E,W
1532:  MOVWF  46
1534:  MOVF   4B,W
1536:  SUBWFB 4F,W
1538:  MOVWF  47
153A:  MOVF   4C,W
153C:  SUBWFB 50,W
153E:  MOVWF  48
1540:  MOVF   4D,W
1542:  SUBWFB 51,W
1544:  MOVWF  49
....................   e1_r=e2_r; 
1546:  MOVFF  51,4D
154A:  MOVFF  50,4C
154E:  MOVFF  4F,4B
1552:  MOVFF  4E,4A
....................    temp_kp = (signed int16)((float)kp_r*e2_r); 
1556:  MOVFF  51,DC
155A:  MOVFF  50,DB
155E:  MOVFF  4F,DA
1562:  MOVFF  4E,D9
1566:  RCALL  1462
1568:  CLRF   16
156A:  BTFSC  FF2.7
156C:  BSF    16.7
156E:  BCF    FF2.7
1570:  MOVFF  65,14D
1574:  MOVFF  64,14C
1578:  MOVFF  63,14B
157C:  MOVFF  62,14A
1580:  MOVFF  03,151
1584:  MOVFF  02,150
1588:  MOVFF  01,14F
158C:  MOVFF  00,14E
1590:  CALL   018E
1594:  BTFSC  16.7
1596:  BSF    FF2.7
1598:  MOVFF  03,116
159C:  MOVFF  02,115
15A0:  MOVFF  01,114
15A4:  MOVFF  00,113
15A8:  RCALL  14B8
15AA:  MOVFF  02,D2
15AE:  MOVFF  01,D1
....................    temp_ki = (signed int16)((float)ki_r*e_sum_r); 
15B2:  MOVFF  45,DC
15B6:  MOVFF  44,DB
15BA:  MOVFF  43,DA
15BE:  MOVFF  42,D9
15C2:  RCALL  1462
15C4:  CLRF   16
15C6:  BTFSC  FF2.7
15C8:  BSF    16.7
15CA:  BCF    FF2.7
15CC:  MOVFF  6D,14D
15D0:  MOVFF  6C,14C
15D4:  MOVFF  6B,14B
15D8:  MOVFF  6A,14A
15DC:  MOVFF  03,151
15E0:  MOVFF  02,150
15E4:  MOVFF  01,14F
15E8:  MOVFF  00,14E
15EC:  CALL   018E
15F0:  BTFSC  16.7
15F2:  BSF    FF2.7
15F4:  MOVFF  03,116
15F8:  MOVFF  02,115
15FC:  MOVFF  01,114
1600:  MOVFF  00,113
1604:  RCALL  14B8
1606:  MOVFF  02,D4
160A:  MOVFF  01,D3
....................    temp_kd = (signed int16)((float)kd_r*e_del_r); 
160E:  MOVFF  49,DC
1612:  MOVFF  48,DB
1616:  MOVFF  47,DA
161A:  MOVFF  46,D9
161E:  RCALL  1462
1620:  CLRF   16
1622:  BTFSC  FF2.7
1624:  BSF    16.7
1626:  BCF    FF2.7
1628:  MOVFF  69,14D
162C:  MOVFF  68,14C
1630:  MOVFF  67,14B
1634:  MOVFF  66,14A
1638:  MOVFF  03,151
163C:  MOVFF  02,150
1640:  MOVFF  01,14F
1644:  MOVFF  00,14E
1648:  CALL   018E
164C:  BTFSC  16.7
164E:  BSF    FF2.7
1650:  MOVFF  03,116
1654:  MOVFF  02,115
1658:  MOVFF  01,114
165C:  MOVFF  00,113
1660:  RCALL  14B8
1662:  MOVFF  02,D6
1666:  MOVFF  01,D5
....................    
....................    pw_duty_Right_Temp = (signed int16)( temp_kp + temp_ki + temp_kd); 
166A:  MOVF   xD3,W
166C:  ADDWF  xD1,W
166E:  MOVWF  xD9
1670:  MOVF   xD4,W
1672:  ADDWFC xD2,W
1674:  MOVWF  xDA
1676:  MOVF   xD5,W
1678:  ADDWF  xD9,W
167A:  MOVWF  xD7
167C:  MOVF   xD6,W
167E:  ADDWFC xDA,W
1680:  MOVWF  xD8
....................    if ( pw_duty_Right_Temp > nguong_right) 
1682:  BTFSC  xD8.7
1684:  BRA    169E
1686:  MOVF   xD8,W
1688:  SUBLW  02
168A:  BC    169E
168C:  XORLW  FF
168E:  BNZ   1696
1690:  MOVF   xD7,W
1692:  SUBLW  E8
1694:  BC    169E
....................    { 
....................    pw_duty_Right_Temp=nguong_right; 
1696:  MOVLW  03
1698:  MOVWF  xD8
169A:  MOVLW  E8
169C:  MOVWF  xD7
....................    } 
....................    if (pw_duty_Right_Temp < -nguong_right) 
169E:  BTFSS  xD8.7
16A0:  BRA    16B8
16A2:  MOVF   xD8,W
16A4:  SUBLW  FC
16A6:  BNC   16B8
16A8:  BNZ   16B0
16AA:  MOVF   xD7,W
16AC:  SUBLW  17
16AE:  BNC   16B8
....................    { 
....................    pw_duty_Right_Temp=-nguong_right; 
16B0:  MOVLW  FC
16B2:  MOVWF  xD8
16B4:  MOVLW  18
16B6:  MOVWF  xD7
....................    } 
....................    if ( pw_duty_Right_Temp>0) 
16B8:  BTFSC  xD8.7
16BA:  BRA    16F0
16BC:  MOVF   xD8,F
16BE:  BNZ   16C6
16C0:  MOVF   xD7,W
16C2:  SUBLW  00
16C4:  BC    16F0
....................    { 
....................    DIR_RIGHT=1; 
16C6:  BSF    F84.0
....................     set_pwm1_duty(pw_duty_Right_Temp); 
16C8:  MOVFF  D8,02
16CC:  MOVFF  D7,01
16D0:  RRCF   02,F
16D2:  RRCF   01,F
16D4:  RRCF   02,F
16D6:  RRCF   01,F
16D8:  RRCF   02,F
16DA:  MOVFF  01,FBE
16DE:  RRCF   02,F
16E0:  RRCF   02,W
16E2:  ANDLW  30
16E4:  MOVWF  00
16E6:  MOVF   FBD,W
16E8:  ANDLW  CF
16EA:  IORWF  00,W
16EC:  MOVWF  FBD
....................    } 
....................    else  
16EE:  BRA    1754
....................    { 
....................     DIR_RIGHT=0; 
16F0:  BCF    F84.0
....................     trunggian=abs(pw_duty_Right_Temp); 
16F2:  MOVFF  D8,03
16F6:  MOVF   xD7,W
16F8:  BTFSS  xD8.7
16FA:  BRA    170C
16FC:  MOVLW  00
16FE:  BSF    FD8.0
1700:  SUBFWB xD7,W
1702:  MOVWF  00
1704:  MOVLW  00
1706:  SUBFWB xD8,W
1708:  MOVWF  03
170A:  MOVF   00,W
170C:  MOVWF  00
170E:  MOVFF  03,01
1712:  CLRF   02
1714:  CLRF   03
1716:  BTFSS  01.7
1718:  BRA    171E
171A:  DECF   02,F
171C:  DECF   03,F
171E:  MOVFF  03,2D
1722:  MOVFF  02,2C
1726:  MOVFF  01,2B
172A:  MOVFF  00,2A
....................     set_pwm1_duty( trunggian); 
172E:  MOVFF  2B,02
1732:  MOVFF  2A,01
1736:  RRCF   02,F
1738:  RRCF   01,F
173A:  RRCF   02,F
173C:  RRCF   01,F
173E:  RRCF   02,F
1740:  MOVFF  01,FBE
1744:  RRCF   02,F
1746:  RRCF   02,W
1748:  ANDLW  30
174A:  MOVWF  00
174C:  MOVF   FBD,W
174E:  ANDLW  CF
1750:  IORWF  00,W
1752:  MOVWF  FBD
....................    }  
....................    if ( ((huong=='L')||(huong=='R'))) 
1754:  MOVF   x90,W
1756:  SUBLW  4C
1758:  BZ    1760
175A:  MOVF   x90,W
175C:  SUBLW  52
175E:  BNZ   17AC
....................    { 
....................     if((e2_r>-100)&&(e2_r<100)) 
1760:  BTFSS  51.7
1762:  BRA    1788
1764:  MOVF   51,W
1766:  SUBLW  FE
1768:  BC    17A8
176A:  XORLW  FF
176C:  BNZ   1788
176E:  MOVF   50,W
1770:  SUBLW  FE
1772:  BC    17A8
1774:  XORLW  FF
1776:  BNZ   1788
1778:  MOVF   4F,W
177A:  SUBLW  FE
177C:  BC    17A8
177E:  XORLW  FF
1780:  BNZ   1788
1782:  MOVF   4E,W
1784:  SUBLW  9C
1786:  BC    17A8
1788:  BTFSC  51.7
178A:  BRA    179E
178C:  MOVF   51,F
178E:  BNZ   17A8
1790:  MOVF   50,F
1792:  BNZ   17A8
1794:  MOVF   4F,F
1796:  BNZ   17A8
1798:  MOVF   4E,W
179A:  SUBLW  63
179C:  BNC   17A8
....................    { 
....................        DIR_RIGHT=0; 
179E:  BCF    F84.0
....................        A=0; 
17A0:  BCF    F82.1
....................       set_pwm1_duty( 0); 
17A2:  CLRF   FBE
....................       copid_right=1; 
17A4:  BSF    x8E.0
....................    } 
....................    else  
17A6:  BRA    17AA
....................    { 
....................       copid_right=0; 
17A8:  BCF    x8E.0
....................    } 
....................    } 
....................    else 
17AA:  BRA    17F6
....................    { 
....................    if((e2_r>-40)&&(e2_r<40)) 
17AC:  BTFSS  51.7
17AE:  BRA    17D4
17B0:  MOVF   51,W
17B2:  SUBLW  FE
17B4:  BC    17F4
17B6:  XORLW  FF
17B8:  BNZ   17D4
17BA:  MOVF   50,W
17BC:  SUBLW  FE
17BE:  BC    17F4
17C0:  XORLW  FF
17C2:  BNZ   17D4
17C4:  MOVF   4F,W
17C6:  SUBLW  FE
17C8:  BC    17F4
17CA:  XORLW  FF
17CC:  BNZ   17D4
17CE:  MOVF   4E,W
17D0:  SUBLW  D8
17D2:  BC    17F4
17D4:  BTFSC  51.7
17D6:  BRA    17EA
17D8:  MOVF   51,F
17DA:  BNZ   17F4
17DC:  MOVF   50,F
17DE:  BNZ   17F4
17E0:  MOVF   4F,F
17E2:  BNZ   17F4
17E4:  MOVF   4E,W
17E6:  SUBLW  27
17E8:  BNC   17F4
....................    { 
....................        DIR_RIGHT=0; 
17EA:  BCF    F84.0
....................        A=0; 
17EC:  BCF    F82.1
....................       set_pwm1_duty( 0); 
17EE:  CLRF   FBE
....................       copid_right=1; 
17F0:  BSF    x8E.0
....................    } 
....................    else  
17F2:  BRA    17F6
....................    { 
....................       copid_right=0; 
17F4:  BCF    x8E.0
....................    } 
....................    } 
.................... } 
17F6:  GOTO   24AA (RETURN)
.................... /* 
.................... void chay() 
.................... { 
.................... A=1; 
.................... //B=1; 
.................... //output_high(pin_E1); 
.................... DIR_RIGHT=1; 
.................... //DIR_LEFT=1; 
....................   //set_pwm2_duty(255);  
....................   set_pwm1_duty(255); 
....................   delay_ms(2000); 
....................  // output_low(pin_E1); 
....................  DIR_RIGHT=0; 
....................  //DIR_LEFT=0; 
....................  // set_pwm2_duty(255); 
....................   set_pwm1_duty(255); 
....................   delay_ms(2000); 
.................... }*/ 

Configuration Fuses:
   Word  1: CC24   IESO FCMEN HS PLL5 CPUDIV1 USBDIV
   Word  2: 1E39   NOBROWNOUT NOWDT BORV20 NOPUT WDT32768 VREGEN
   Word  3: 8700   PBADEN CCP2C1 MCLR LPT1OSC
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST NOICPRT
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
